// Ver:1
// GeneratedBy:c:\users\jukai\documents\unreal projects\haxetest\plugins\unrealhx/haxe/externs/ue4.27/unreal/uaudiocomponent.hx
package unreal;
/**
  
  AudioComponent is used to play a Sound
  
  @see https://docs.unrealengine.com/latest/INT/Audio/Overview/index.html
  @see USoundBase
  
**/

@:umodule("Unreal")
@:glueCppIncludes("Components/AudioComponent.h")
@:uextern
@:uclass
@:ueGluePath("uhx.glues.UAudioComponent_Glue")
#if (cppia && !LIVE_RELOAD_BUILD && !macro) @:build(uhx.compiletime.types.CompiledMetaCheck.build("unreal.UAudioComponent")) #end
class UAudioComponent #if !macro extends unreal.USceneComponent #end {
  #if !macro 
  /**
    
    Socket we automatically attach to on the AutoAttachParent, if bAutoManageAttachment is true.
    @see bAutoManageAttachment
    
  **/
  
  @:uproperty
  public var AutoAttachSocketName(get,set):unreal.PPtr<unreal.PPtr<unreal.FName>>;
  /**
    
    Component we automatically attach to when activated, if bAutoManageAttachment is true.
    If null during registration, we assign the existing AttachParent and defer attachment until we activate.
    @see bAutoManageAttachment
    
  **/
  
  @:uproperty
  public var AutoAttachParent(get,set):unreal.TWeakObjectPtr<unreal.USceneComponent>;
  /**
    
    Called when subtitles are sent to the SubtitleManager.  Set this delegate if you want to hijack the subtitles for other purposes
    
  **/
  
  @:uproperty
  public var OnQueueSubtitles(get,set):unreal.PPtr<unreal.FOnQueueSubtitles>;
  @:uproperty
  public var OnAudioMultiEnvelopeValue(get,set):unreal.PPtr<unreal.FOnAudioMultiEnvelopeValue>;
  @:uproperty
  public var OnAudioSingleEnvelopeValue(get,set):unreal.PPtr<unreal.FOnAudioSingleEnvelopeValue>;
  /**
    
    Called as a sound plays on the audio component to allow BP to perform actions based on playback percentage.
    Computed as samples played divided by total samples, taking into account pitch.
    Not currently implemented on all platforms.
    
  **/
  
  @:uproperty
  public var OnAudioPlaybackPercent(get,set):unreal.PPtr<unreal.FOnAudioPlaybackPercent>;
  /**
    
    Called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early
    
  **/
  
  @:uproperty
  public var OnAudioFinished(get,set):unreal.PPtr<unreal.FOnAudioFinished>;
  /**
    
    Called when virtualization state changes
    
  **/
  
  @:uproperty
  public var OnAudioVirtualizationChanged(get,set):unreal.PPtr<unreal.FOnAudioVirtualizationChanged>;
  /**
    
    This function returns the Targeted Audio Componentâ€™s current Play State.
    Playing, if the sound is currently playing.
    Stopped, if the sound is stopped.
    Paused, if the sound is currently playing, but paused.
    Fading In, if the sound is in the process of Fading In.
    Fading Out, if the sound is in the process of Fading Out.
    
  **/
  
  @:uproperty
  public var OnAudioPlayStateChanged(get,set):unreal.PPtr<unreal.FOnAudioPlayStateChanged>;
  @:uproperty
  public var ModulationRouting(get,set):unreal.PPtr<unreal.FSoundModulationDefaultRoutingSettings>;
  /**
    
    Options for how we handle our scale when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
    @see bAutoManageAttachment, EAttachmentRule
    
  **/
  
  @:uproperty
  public var AutoAttachScaleRule(get,set):unreal.EAttachmentRule;
  /**
    
    Options for how we handle our rotation when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
    @see bAutoManageAttachment, EAttachmentRule
    
  **/
  
  @:uproperty
  public var AutoAttachRotationRule(get,set):unreal.EAttachmentRule;
  /**
    
    Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
    @see bAutoManageAttachment, EAttachmentRule
    
  **/
  
  @:uproperty
  public var AutoAttachLocationRule(get,set):unreal.EAttachmentRule;
  /**
    
    What sound concurrency rules to use for sounds generated by this audio component
    
  **/
  
  @:uproperty
  public var ConcurrencySet(get,set):unreal.PPtr<unreal.TSet<unreal.USoundConcurrency>>;
  /**
    
    What sound concurrency to use for sounds generated by this audio component
    
  **/
  
  @:deprecated
  @:uproperty
  public var ConcurrencySettings_DEPRECATED(get,set):unreal.USoundConcurrency;
  /**
    
    If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component
    
  **/
  
  @:uproperty
  public var AttenuationOverrides(get,set):unreal.PPtr<unreal.FSoundAttenuationSettings>;
  /**
    
    If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component
    
  **/
  
  @:uproperty
  public var AttenuationSettings(get,set):unreal.USoundAttenuation;
  /**
    
    The frequency of the Lowpass Filter (in Hz) to apply to this voice. A frequency of 0.0 is the device sample rate and will bypass the filter.
    
  **/
  
  @:uproperty
  public var LowPassFilterFrequency(get,set):cpp.Float32;
  /**
    
    A pitch multiplier to apply to sounds generated by this component
    
  **/
  
  @:uproperty
  public var PitchMultiplier(get,set):cpp.Float32;
  @:deprecated
  @:uproperty
  public var HighFrequencyGainMultiplier_DEPRECATED(get,set):cpp.Float32;
  @:deprecated
  @:uproperty
  public var VolumeWeightedPriorityScale_DEPRECATED(get,set):cpp.Float32;
  /**
    
    The chain of Source Effects to apply to the sounds playing on the Audio Component
    
  **/
  
  @:uproperty
  public var SourceEffectChain(get,set):unreal.USoundEffectSourcePresetChain;
  /**
    
    Used by the subtitle manager to prioritize subtitles wave instances spawned by this component.
    
  **/
  
  @:uproperty
  public var SubtitlePriority(get,set):cpp.Float32;
  /**
    
    A priority value that is used for sounds that play on this component that scales against final output volume.
    
  **/
  
  @:uproperty
  public var Priority(get,set):cpp.Float32;
  /**
    
    The release time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the
    envelope value of sounds played with this audio component. Only used in audio mixer.
    
  **/
  
  @:uproperty
  public var EnvelopeFollowerReleaseTime(get,set):Int;
  /**
    
    The attack time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the
    envelope value of sounds played with this audio component. Only used in audio mixer.
    
  **/
  
  @:uproperty
  public var EnvelopeFollowerAttackTime(get,set):Int;
  /**
    
    A volume multiplier to apply to sounds generated by this component
    
  **/
  
  @:uproperty
  public var VolumeMultiplier(get,set):cpp.Float32;
  /**
    
    The upper bound to use when randomly determining a volume multiplier
    
  **/
  
  @:uproperty
  public var VolumeModulationMax(get,set):cpp.Float32;
  /**
    
    The lower bound to use when randomly determining a volume multiplier
    
  **/
  
  @:uproperty
  public var VolumeModulationMin(get,set):cpp.Float32;
  /**
    
    The upper bound to use when randomly determining a pitch multiplier
    
  **/
  
  @:uproperty
  public var PitchModulationMax(get,set):cpp.Float32;
  /**
    
    The lower bound to use when randomly determining a pitch multiplier
    
  **/
  
  @:uproperty
  public var PitchModulationMin(get,set):cpp.Float32;
  /**
    
    Configurable, serialized ID for audio plugins
    
  **/
  
  @:uproperty
  public var AudioComponentUserID(get,set):unreal.PPtr<unreal.PPtr<unreal.FName>>;
  /**
    
    True if we should automatically attach to AutoAttachParent when Played, and detach from our parent when playback is completed.
    This overrides any current attachment that may be present at the time of activation (deferring initial attachment until activation, if AutoAttachParent is null).
    If enabled, this AudioComponent's WorldLocation will no longer be reliable when not currently playing audio, and any attach children will also be
    detached/attached along with it.
    When enabled, detachment occurs regardless of whether AutoAttachParent is assigned, and the relative transform from the time of activation is restored.
    This also disables attachment on dedicated servers, where we don't actually activate even if bAutoActivate is true.
    @see AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType
    
  **/
  
  @:uproperty
  public var bAutoManageAttachment(get,set):Bool;
  /**
    
    If true, subtitles in the sound data will be ignored.
    
  **/
  
  @:uproperty
  public var bSuppressSubtitles(get,set):Bool;
  @:uproperty
  public var bOverridePriority(get,set):Bool;
  /**
    
    Whether or not to apply a low-pass filter to the sound that plays in this audio component.
    
  **/
  
  @:uproperty
  public var bEnableLowPassFilter(get,set):Bool;
  /**
    
    Whether or not this sound plays when the game is paused in the UI
    
  **/
  
  @:uproperty
  public var bIsUISound(get,set):Bool;
  /**
    
    Whether or not to override the sound's subtitle priority.
    
  **/
  
  @:uproperty
  public var bOverrideSubtitlePriority(get,set):Bool;
  /**
    
    Allows defining attenuation settings directly on this audio component without using an attenuation settings asset.
    
  **/
  
  @:uproperty
  public var bOverrideAttenuation(get,set):Bool;
  /**
    
    Overrides spatialization enablement in either the attenuation asset or on this audio component's attenuation settings override.
    
  **/
  
  @:uproperty
  public var bAllowSpatialization(get,set):Bool;
  /**
    
    Whether the wave instances should remain active if they're dropped by the prioritization code. Useful for e.g. vehicle sounds that shouldn't cut out.
    
  **/
  
  @:uproperty
  public var bShouldRemainActiveIfDropped(get,set):Bool;
  /**
    
    Stop sound when owner is destroyed
    
  **/
  
  @:uproperty
  public var bStopWhenOwnerDestroyed(get,set):Bool;
  /**
    
    Auto destroy this component on completion
    
  **/
  
  @:uproperty
  public var bAutoDestroy(get,set):Bool;
  /**
    
    Optional sound group this AudioComponent belongs to
    
  **/
  
  @:uproperty
  public var SoundClassOverride(get,set):unreal.USoundClass;
  /**
    
    Array of per-instance parameters for this AudioComponent.
    
  **/
  
  @:uproperty
  public var InstanceParameters(get,set):unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FAudioComponentParam>>>;
  /**
    
    The sound to be played
    
  **/
  
  @:uproperty
  public var Sound(get,set):unreal.USoundBase;
  public var bIgnoreForFlushing(get,set):Bool;
  static function __init__():Void {
    #if !cppia
    var func = cpp.Function.fromStaticFunction(wrapPointer).toFunction();
    uhx.ue.ClassMap.addWrapper(uhx.glues.UAudioComponent_Glue.StaticClass(), func);
    #else
    uhx.runtime.Helpers.addCppiaExternWrapper("AudioComponent", "unreal.UAudioComponent");
    #end
  }
  
  #if !cppia
  static function wrapPointer(uobject:unreal.UIntPtr):unreal.UIntPtr {
    return uhx.internal.HaxeHelpers.dynamicToPointer(new unreal.UAudioComponent(uobject));
  }
  #end
  inline public static function wrap(uobject:unreal.UIntPtr):unreal.UAudioComponent {
    return cast uhx.ClassWrap.wrap(uobject);
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_AutoAttachSocketName(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_AutoAttachSocketName(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->AutoAttachSocketName)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AutoAttachSocketName() : unreal.PPtr<unreal.PPtr<unreal.FName>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AutoAttachSocketName");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AutoAttachSocketName");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FNameImpl.fromPointer( uhx.glues.UAudioComponent_Glue.get_AutoAttachSocketName(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.FName>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_AutoAttachSocketName(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AutoAttachSocketName(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->AutoAttachSocketName = *::uhx::StructHelper< FName >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AutoAttachSocketName(value : unreal.FName) : unreal.FName {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AutoAttachSocketName");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AutoAttachSocketName", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_AutoAttachSocketName(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "UObject/WeakObjectPtr.h", "UObject/WeakObjectPtrTemplates.h", "Components/SceneComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_AutoAttachParent(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::get_AutoAttachParent(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (( ( (UAudioComponent *) self )->AutoAttachParent.Get() )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AutoAttachParent() : unreal.TWeakObjectPtr<unreal.USceneComponent> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AutoAttachParent");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AutoAttachParent");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.get_AutoAttachParent(uhx_arg_0)) : unreal.TWeakObjectPtr<unreal.USceneComponent> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "UObject/WeakObjectPtr.h", "UObject/WeakObjectPtrTemplates.h", "Components/SceneComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_AutoAttachParent(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AutoAttachParent(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (UAudioComponent *) self )->AutoAttachParent = ( (TWeakObjectPtr<USceneComponent>) ( (USceneComponent *) value ) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AutoAttachParent(value : unreal.TWeakObjectPtr<unreal.USceneComponent>) : unreal.TWeakObjectPtr<unreal.USceneComponent> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AutoAttachParent");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AutoAttachParent", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.UAudioComponent_Glue.set_AutoAttachParent(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnQueueSubtitles(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnQueueSubtitles(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnQueueSubtitles)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnQueueSubtitles() : unreal.PPtr<unreal.FOnQueueSubtitles> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnQueueSubtitles");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnQueueSubtitles");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnQueueSubtitles.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnQueueSubtitles(uhx_arg_0) ) : unreal.PPtr<unreal.FOnQueueSubtitles> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnQueueSubtitles(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnQueueSubtitles(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnQueueSubtitles = *::uhx::StructHelper< FOnQueueSubtitles >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnQueueSubtitles(value : unreal.FOnQueueSubtitles) : unreal.FOnQueueSubtitles {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnQueueSubtitles");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnQueueSubtitles", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnQueueSubtitles(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioMultiEnvelopeValue(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnAudioMultiEnvelopeValue(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnAudioMultiEnvelopeValue)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioMultiEnvelopeValue() : unreal.PPtr<unreal.FOnAudioMultiEnvelopeValue> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioMultiEnvelopeValue");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioMultiEnvelopeValue");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnAudioMultiEnvelopeValue.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnAudioMultiEnvelopeValue(uhx_arg_0) ) : unreal.PPtr<unreal.FOnAudioMultiEnvelopeValue> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioMultiEnvelopeValue(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnAudioMultiEnvelopeValue(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnAudioMultiEnvelopeValue = *::uhx::StructHelper< FOnAudioMultiEnvelopeValue >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioMultiEnvelopeValue(value : unreal.FOnAudioMultiEnvelopeValue) : unreal.FOnAudioMultiEnvelopeValue {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioMultiEnvelopeValue");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioMultiEnvelopeValue", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnAudioMultiEnvelopeValue(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioSingleEnvelopeValue(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnAudioSingleEnvelopeValue(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnAudioSingleEnvelopeValue)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioSingleEnvelopeValue() : unreal.PPtr<unreal.FOnAudioSingleEnvelopeValue> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioSingleEnvelopeValue");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioSingleEnvelopeValue");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnAudioSingleEnvelopeValue.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnAudioSingleEnvelopeValue(uhx_arg_0) ) : unreal.PPtr<unreal.FOnAudioSingleEnvelopeValue> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioSingleEnvelopeValue(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnAudioSingleEnvelopeValue(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnAudioSingleEnvelopeValue = *::uhx::StructHelper< FOnAudioSingleEnvelopeValue >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioSingleEnvelopeValue(value : unreal.FOnAudioSingleEnvelopeValue) : unreal.FOnAudioSingleEnvelopeValue {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioSingleEnvelopeValue");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioSingleEnvelopeValue", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnAudioSingleEnvelopeValue(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioPlaybackPercent(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnAudioPlaybackPercent(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnAudioPlaybackPercent)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioPlaybackPercent() : unreal.PPtr<unreal.FOnAudioPlaybackPercent> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioPlaybackPercent");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioPlaybackPercent");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnAudioPlaybackPercent.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnAudioPlaybackPercent(uhx_arg_0) ) : unreal.PPtr<unreal.FOnAudioPlaybackPercent> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioPlaybackPercent(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnAudioPlaybackPercent(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnAudioPlaybackPercent = *::uhx::StructHelper< FOnAudioPlaybackPercent >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioPlaybackPercent(value : unreal.FOnAudioPlaybackPercent) : unreal.FOnAudioPlaybackPercent {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioPlaybackPercent");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioPlaybackPercent", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnAudioPlaybackPercent(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioFinished(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnAudioFinished(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnAudioFinished)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioFinished() : unreal.PPtr<unreal.FOnAudioFinished> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioFinished");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioFinished");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnAudioFinished.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnAudioFinished(uhx_arg_0) ) : unreal.PPtr<unreal.FOnAudioFinished> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioFinished(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnAudioFinished(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnAudioFinished = *::uhx::StructHelper< FOnAudioFinished >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioFinished(value : unreal.FOnAudioFinished) : unreal.FOnAudioFinished {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioFinished");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioFinished", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnAudioFinished(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioVirtualizationChanged(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnAudioVirtualizationChanged(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnAudioVirtualizationChanged)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioVirtualizationChanged() : unreal.PPtr<unreal.FOnAudioVirtualizationChanged> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioVirtualizationChanged");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioVirtualizationChanged");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnAudioVirtualizationChanged.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnAudioVirtualizationChanged(uhx_arg_0) ) : unreal.PPtr<unreal.FOnAudioVirtualizationChanged> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioVirtualizationChanged(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnAudioVirtualizationChanged(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnAudioVirtualizationChanged = *::uhx::StructHelper< FOnAudioVirtualizationChanged >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioVirtualizationChanged(value : unreal.FOnAudioVirtualizationChanged) : unreal.FOnAudioVirtualizationChanged {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioVirtualizationChanged");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioVirtualizationChanged", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnAudioVirtualizationChanged(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioPlayStateChanged(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_OnAudioPlayStateChanged(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->OnAudioPlayStateChanged)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioPlayStateChanged() : unreal.PPtr<unreal.FOnAudioPlayStateChanged> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioPlayStateChanged");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioPlayStateChanged");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FOnAudioPlayStateChanged.fromPointer( uhx.glues.UAudioComponent_Glue.get_OnAudioPlayStateChanged(uhx_arg_0) ) : unreal.PPtr<unreal.FOnAudioPlayStateChanged> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioPlayStateChanged(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_OnAudioPlayStateChanged(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->OnAudioPlayStateChanged = *::uhx::StructHelper< FOnAudioPlayStateChanged >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioPlayStateChanged(value : unreal.FOnAudioPlayStateChanged) : unreal.FOnAudioPlayStateChanged {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioPlayStateChanged");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioPlayStateChanged", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_OnAudioPlayStateChanged(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundModulationDestination.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_ModulationRouting(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_ModulationRouting(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->ModulationRouting)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_ModulationRouting() : unreal.PPtr<unreal.FSoundModulationDefaultRoutingSettings> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_ModulationRouting");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "ModulationRouting");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FSoundModulationDefaultRoutingSettings.fromPointer( uhx.glues.UAudioComponent_Glue.get_ModulationRouting(uhx_arg_0) ) : unreal.PPtr<unreal.FSoundModulationDefaultRoutingSettings> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundModulationDestination.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_ModulationRouting(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_ModulationRouting(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->ModulationRouting = *::uhx::StructHelper< FSoundModulationDefaultRoutingSettings >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_ModulationRouting(value : unreal.FSoundModulationDefaultRoutingSettings) : unreal.FSoundModulationDefaultRoutingSettings {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_ModulationRouting");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "ModulationRouting", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_ModulationRouting(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Engine/EngineTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_AutoAttachScaleRule(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::UAudioComponent_Glue_obj::get_AutoAttachScaleRule(unreal::UIntPtr self) {\n\treturn ( (int) (EAttachmentRule) ( (UAudioComponent *) self )->AutoAttachScaleRule );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AutoAttachScaleRule() : unreal.EAttachmentRule {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AutoAttachScaleRule");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AutoAttachScaleRule");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return unreal.EAttachmentRule.EAttachmentRule_EnumConv.wrap(uhx.glues.UAudioComponent_Glue.get_AutoAttachScaleRule(uhx_arg_0));
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Engine/EngineTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_AutoAttachScaleRule(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AutoAttachScaleRule(unreal::UIntPtr self, int value) {\n\t( (UAudioComponent *) self )->AutoAttachScaleRule = ( (EAttachmentRule) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AutoAttachScaleRule(value : unreal.EAttachmentRule) : unreal.EAttachmentRule {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AutoAttachScaleRule");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AutoAttachScaleRule", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = unreal.EAttachmentRule.EAttachmentRule_EnumConv.unwrap(value);
    uhx.glues.UAudioComponent_Glue.set_AutoAttachScaleRule(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Engine/EngineTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_AutoAttachRotationRule(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::UAudioComponent_Glue_obj::get_AutoAttachRotationRule(unreal::UIntPtr self) {\n\treturn ( (int) (EAttachmentRule) ( (UAudioComponent *) self )->AutoAttachRotationRule );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AutoAttachRotationRule() : unreal.EAttachmentRule {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AutoAttachRotationRule");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AutoAttachRotationRule");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return unreal.EAttachmentRule.EAttachmentRule_EnumConv.wrap(uhx.glues.UAudioComponent_Glue.get_AutoAttachRotationRule(uhx_arg_0));
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Engine/EngineTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_AutoAttachRotationRule(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AutoAttachRotationRule(unreal::UIntPtr self, int value) {\n\t( (UAudioComponent *) self )->AutoAttachRotationRule = ( (EAttachmentRule) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AutoAttachRotationRule(value : unreal.EAttachmentRule) : unreal.EAttachmentRule {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AutoAttachRotationRule");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AutoAttachRotationRule", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = unreal.EAttachmentRule.EAttachmentRule_EnumConv.unwrap(value);
    uhx.glues.UAudioComponent_Glue.set_AutoAttachRotationRule(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Engine/EngineTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_AutoAttachLocationRule(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::UAudioComponent_Glue_obj::get_AutoAttachLocationRule(unreal::UIntPtr self) {\n\treturn ( (int) (EAttachmentRule) ( (UAudioComponent *) self )->AutoAttachLocationRule );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AutoAttachLocationRule() : unreal.EAttachmentRule {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AutoAttachLocationRule");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AutoAttachLocationRule");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return unreal.EAttachmentRule.EAttachmentRule_EnumConv.wrap(uhx.glues.UAudioComponent_Glue.get_AutoAttachLocationRule(uhx_arg_0));
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Engine/EngineTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_AutoAttachLocationRule(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AutoAttachLocationRule(unreal::UIntPtr self, int value) {\n\t( (UAudioComponent *) self )->AutoAttachLocationRule = ( (EAttachmentRule) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AutoAttachLocationRule(value : unreal.EAttachmentRule) : unreal.EAttachmentRule {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AutoAttachLocationRule");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AutoAttachLocationRule", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = unreal.EAttachmentRule.EAttachmentRule_EnumConv.unwrap(value);
    uhx.glues.UAudioComponent_Glue.set_AutoAttachLocationRule(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Set.h", "Sound/SoundConcurrency.h", "uhx/glues/TSet_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_ConcurrencySet(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_ConcurrencySet(unreal::UIntPtr self) {\n\treturn ::uhx::TemplateHelper<TSet<USoundConcurrency *>>::fromPointer( (&(( (UAudioComponent *) self )->ConcurrencySet)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_ConcurrencySet() : unreal.PPtr<unreal.TSet<unreal.USoundConcurrency>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_ConcurrencySet");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "ConcurrencySet");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.TSet.fromPointer( uhx.glues.UAudioComponent_Glue.get_ConcurrencySet(uhx_arg_0) ) : unreal.PPtr<unreal.TSet<unreal.USoundConcurrency>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Set.h", "Sound/SoundConcurrency.h", "uhx/glues/TSet_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_ConcurrencySet(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_ConcurrencySet(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->ConcurrencySet = *::uhx::TemplateHelper< TSet<USoundConcurrency *> >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_ConcurrencySet(value : unreal.TSet<unreal.USoundConcurrency>) : unreal.TSet<unreal.USoundConcurrency> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_ConcurrencySet");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "ConcurrencySet", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_ConcurrencySet(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundConcurrency.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::get_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundConcurrency * >( ( (UAudioComponent *) self )->ConcurrencySettings_DEPRECATED )) );\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_ConcurrencySettings_DEPRECATED() : unreal.USoundConcurrency {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_ConcurrencySettings_DEPRECATED");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "ConcurrencySettings_DEPRECATED");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.get_ConcurrencySettings_DEPRECATED(uhx_arg_0)) : unreal.USoundConcurrency );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundConcurrency.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (UAudioComponent *) self )->ConcurrencySettings_DEPRECATED = ( (USoundConcurrency *) value );\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_ConcurrencySettings_DEPRECATED(value : unreal.USoundConcurrency) : unreal.USoundConcurrency {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_ConcurrencySettings_DEPRECATED");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "ConcurrencySettings_DEPRECATED", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.UAudioComponent_Glue.set_ConcurrencySettings_DEPRECATED(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_AttenuationOverrides(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_AttenuationOverrides(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->AttenuationOverrides)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AttenuationOverrides() : unreal.PPtr<unreal.FSoundAttenuationSettings> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AttenuationOverrides");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AttenuationOverrides");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FSoundAttenuationSettings.fromPointer( uhx.glues.UAudioComponent_Glue.get_AttenuationOverrides(uhx_arg_0) ) : unreal.PPtr<unreal.FSoundAttenuationSettings> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_AttenuationOverrides(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AttenuationOverrides(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->AttenuationOverrides = *::uhx::StructHelper< FSoundAttenuationSettings >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AttenuationOverrides(value : unreal.FSoundAttenuationSettings) : unreal.FSoundAttenuationSettings {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AttenuationOverrides");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AttenuationOverrides", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_AttenuationOverrides(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_AttenuationSettings(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::get_AttenuationSettings(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundAttenuation * >( ( (UAudioComponent *) self )->AttenuationSettings )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AttenuationSettings() : unreal.USoundAttenuation {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AttenuationSettings");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AttenuationSettings");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.get_AttenuationSettings(uhx_arg_0)) : unreal.USoundAttenuation );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_AttenuationSettings(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AttenuationSettings(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (UAudioComponent *) self )->AttenuationSettings = ( (USoundAttenuation *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AttenuationSettings(value : unreal.USoundAttenuation) : unreal.USoundAttenuation {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AttenuationSettings");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AttenuationSettings", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.UAudioComponent_Glue.set_AttenuationSettings(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_LowPassFilterFrequency(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_LowPassFilterFrequency(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->LowPassFilterFrequency;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_LowPassFilterFrequency() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_LowPassFilterFrequency");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "LowPassFilterFrequency");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_LowPassFilterFrequency(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_LowPassFilterFrequency(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_LowPassFilterFrequency(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->LowPassFilterFrequency = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_LowPassFilterFrequency(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_LowPassFilterFrequency");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "LowPassFilterFrequency", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_LowPassFilterFrequency(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_PitchMultiplier(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_PitchMultiplier(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->PitchMultiplier;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_PitchMultiplier() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_PitchMultiplier");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "PitchMultiplier");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_PitchMultiplier(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_PitchMultiplier(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_PitchMultiplier(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->PitchMultiplier = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_PitchMultiplier(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_PitchMultiplier");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "PitchMultiplier", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_PitchMultiplier(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_HighFrequencyGainMultiplier_DEPRECATED(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_HighFrequencyGainMultiplier_DEPRECATED(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->HighFrequencyGainMultiplier_DEPRECATED;\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_HighFrequencyGainMultiplier_DEPRECATED() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_HighFrequencyGainMultiplier_DEPRECATED");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "HighFrequencyGainMultiplier_DEPRECATED");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_HighFrequencyGainMultiplier_DEPRECATED(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_HighFrequencyGainMultiplier_DEPRECATED(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_HighFrequencyGainMultiplier_DEPRECATED(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->HighFrequencyGainMultiplier_DEPRECATED = value;\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_HighFrequencyGainMultiplier_DEPRECATED(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_HighFrequencyGainMultiplier_DEPRECATED");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "HighFrequencyGainMultiplier_DEPRECATED", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_HighFrequencyGainMultiplier_DEPRECATED(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_VolumeWeightedPriorityScale_DEPRECATED(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_VolumeWeightedPriorityScale_DEPRECATED(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->VolumeWeightedPriorityScale_DEPRECATED;\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_VolumeWeightedPriorityScale_DEPRECATED() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_VolumeWeightedPriorityScale_DEPRECATED");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "VolumeWeightedPriorityScale_DEPRECATED");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_VolumeWeightedPriorityScale_DEPRECATED(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_VolumeWeightedPriorityScale_DEPRECATED(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_VolumeWeightedPriorityScale_DEPRECATED(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->VolumeWeightedPriorityScale_DEPRECATED = value;\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_VolumeWeightedPriorityScale_DEPRECATED(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_VolumeWeightedPriorityScale_DEPRECATED");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "VolumeWeightedPriorityScale_DEPRECATED", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_VolumeWeightedPriorityScale_DEPRECATED(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundEffectSource.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_SourceEffectChain(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::get_SourceEffectChain(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundEffectSourcePresetChain * >( ( (UAudioComponent *) self )->SourceEffectChain )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SourceEffectChain() : unreal.USoundEffectSourcePresetChain {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SourceEffectChain");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SourceEffectChain");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.get_SourceEffectChain(uhx_arg_0)) : unreal.USoundEffectSourcePresetChain );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundEffectSource.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_SourceEffectChain(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_SourceEffectChain(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (UAudioComponent *) self )->SourceEffectChain = ( (USoundEffectSourcePresetChain *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SourceEffectChain(value : unreal.USoundEffectSourcePresetChain) : unreal.USoundEffectSourcePresetChain {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SourceEffectChain");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SourceEffectChain", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.UAudioComponent_Glue.set_SourceEffectChain(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_SubtitlePriority(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_SubtitlePriority(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->SubtitlePriority;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SubtitlePriority() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SubtitlePriority");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SubtitlePriority");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_SubtitlePriority(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_SubtitlePriority(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_SubtitlePriority(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->SubtitlePriority = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SubtitlePriority(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SubtitlePriority");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SubtitlePriority", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_SubtitlePriority(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_Priority(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_Priority(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->Priority;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_Priority() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_Priority");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "Priority");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_Priority(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_Priority(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_Priority(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->Priority = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_Priority(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_Priority");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "Priority", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_Priority(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_EnvelopeFollowerReleaseTime(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::UAudioComponent_Glue_obj::get_EnvelopeFollowerReleaseTime(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->EnvelopeFollowerReleaseTime;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_EnvelopeFollowerReleaseTime() : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_EnvelopeFollowerReleaseTime");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "EnvelopeFollowerReleaseTime");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_EnvelopeFollowerReleaseTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_EnvelopeFollowerReleaseTime(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_EnvelopeFollowerReleaseTime(unreal::UIntPtr self, int value) {\n\t( (UAudioComponent *) self )->EnvelopeFollowerReleaseTime = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_EnvelopeFollowerReleaseTime(value : Int) : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_EnvelopeFollowerReleaseTime");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "EnvelopeFollowerReleaseTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = value;
    uhx.glues.UAudioComponent_Glue.set_EnvelopeFollowerReleaseTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_EnvelopeFollowerAttackTime(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::UAudioComponent_Glue_obj::get_EnvelopeFollowerAttackTime(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->EnvelopeFollowerAttackTime;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_EnvelopeFollowerAttackTime() : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_EnvelopeFollowerAttackTime");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "EnvelopeFollowerAttackTime");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_EnvelopeFollowerAttackTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_EnvelopeFollowerAttackTime(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_EnvelopeFollowerAttackTime(unreal::UIntPtr self, int value) {\n\t( (UAudioComponent *) self )->EnvelopeFollowerAttackTime = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_EnvelopeFollowerAttackTime(value : Int) : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_EnvelopeFollowerAttackTime");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "EnvelopeFollowerAttackTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = value;
    uhx.glues.UAudioComponent_Glue.set_EnvelopeFollowerAttackTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_VolumeMultiplier(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_VolumeMultiplier(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->VolumeMultiplier;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_VolumeMultiplier() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_VolumeMultiplier");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "VolumeMultiplier");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_VolumeMultiplier(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_VolumeMultiplier(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_VolumeMultiplier(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->VolumeMultiplier = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_VolumeMultiplier(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_VolumeMultiplier");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "VolumeMultiplier", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_VolumeMultiplier(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_VolumeModulationMax(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_VolumeModulationMax(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->VolumeModulationMax;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_VolumeModulationMax() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_VolumeModulationMax");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "VolumeModulationMax");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_VolumeModulationMax(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_VolumeModulationMax(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_VolumeModulationMax(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->VolumeModulationMax = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_VolumeModulationMax(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_VolumeModulationMax");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "VolumeModulationMax", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_VolumeModulationMax(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_VolumeModulationMin(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_VolumeModulationMin(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->VolumeModulationMin;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_VolumeModulationMin() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_VolumeModulationMin");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "VolumeModulationMin");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_VolumeModulationMin(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_VolumeModulationMin(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_VolumeModulationMin(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->VolumeModulationMin = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_VolumeModulationMin(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_VolumeModulationMin");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "VolumeModulationMin", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_VolumeModulationMin(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_PitchModulationMax(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_PitchModulationMax(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->PitchModulationMax;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_PitchModulationMax() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_PitchModulationMax");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "PitchModulationMax");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_PitchModulationMax(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_PitchModulationMax(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_PitchModulationMax(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->PitchModulationMax = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_PitchModulationMax(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_PitchModulationMax");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "PitchModulationMax", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_PitchModulationMax(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_PitchModulationMin(unreal::UIntPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::UAudioComponent_Glue_obj::get_PitchModulationMin(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->PitchModulationMin;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_PitchModulationMin() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_PitchModulationMin");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "PitchModulationMin");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_PitchModulationMin(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_PitchModulationMin(unreal::UIntPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_PitchModulationMin(unreal::UIntPtr self, cpp::Float32 value) {\n\t( (UAudioComponent *) self )->PitchModulationMin = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_PitchModulationMin(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_PitchModulationMin");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "PitchModulationMin", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.UAudioComponent_Glue.set_PitchModulationMin(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_AudioComponentUserID(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_AudioComponentUserID(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (UAudioComponent *) self )->AudioComponentUserID)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AudioComponentUserID() : unreal.PPtr<unreal.PPtr<unreal.FName>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AudioComponentUserID");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AudioComponentUserID");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FNameImpl.fromPointer( uhx.glues.UAudioComponent_Glue.get_AudioComponentUserID(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.FName>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_AudioComponentUserID(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_AudioComponentUserID(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->AudioComponentUserID = *::uhx::StructHelper< FName >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AudioComponentUserID(value : unreal.FName) : unreal.FName {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AudioComponentUserID");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AudioComponentUserID", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_AudioComponentUserID(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bAutoManageAttachment(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bAutoManageAttachment(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bAutoManageAttachment;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bAutoManageAttachment() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bAutoManageAttachment");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bAutoManageAttachment");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bAutoManageAttachment(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bAutoManageAttachment(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bAutoManageAttachment(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bAutoManageAttachment = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bAutoManageAttachment(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bAutoManageAttachment");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bAutoManageAttachment", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bAutoManageAttachment(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bSuppressSubtitles(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bSuppressSubtitles(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bSuppressSubtitles;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bSuppressSubtitles() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bSuppressSubtitles");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bSuppressSubtitles");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bSuppressSubtitles(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bSuppressSubtitles(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bSuppressSubtitles(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bSuppressSubtitles = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bSuppressSubtitles(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bSuppressSubtitles");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bSuppressSubtitles", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bSuppressSubtitles(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bOverridePriority(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bOverridePriority(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bOverridePriority;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bOverridePriority() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bOverridePriority");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bOverridePriority");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bOverridePriority(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bOverridePriority(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bOverridePriority(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bOverridePriority = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bOverridePriority(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bOverridePriority");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bOverridePriority", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bOverridePriority(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bEnableLowPassFilter(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bEnableLowPassFilter(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bEnableLowPassFilter;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bEnableLowPassFilter() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bEnableLowPassFilter");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bEnableLowPassFilter");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bEnableLowPassFilter(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bEnableLowPassFilter(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bEnableLowPassFilter(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bEnableLowPassFilter = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bEnableLowPassFilter(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bEnableLowPassFilter");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bEnableLowPassFilter", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bEnableLowPassFilter(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bIsUISound(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bIsUISound(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bIsUISound;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bIsUISound() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bIsUISound");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bIsUISound");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bIsUISound(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bIsUISound(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bIsUISound(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bIsUISound = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bIsUISound(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bIsUISound");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bIsUISound", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bIsUISound(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bOverrideSubtitlePriority(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bOverrideSubtitlePriority(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bOverrideSubtitlePriority;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bOverrideSubtitlePriority() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bOverrideSubtitlePriority");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bOverrideSubtitlePriority");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bOverrideSubtitlePriority(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bOverrideSubtitlePriority(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bOverrideSubtitlePriority(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bOverrideSubtitlePriority = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bOverrideSubtitlePriority(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bOverrideSubtitlePriority");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bOverrideSubtitlePriority", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bOverrideSubtitlePriority(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bOverrideAttenuation(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bOverrideAttenuation(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bOverrideAttenuation;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bOverrideAttenuation() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bOverrideAttenuation");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bOverrideAttenuation");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bOverrideAttenuation(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bOverrideAttenuation(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bOverrideAttenuation(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bOverrideAttenuation = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bOverrideAttenuation(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bOverrideAttenuation");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bOverrideAttenuation", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bOverrideAttenuation(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bAllowSpatialization(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bAllowSpatialization(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bAllowSpatialization;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bAllowSpatialization() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bAllowSpatialization");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bAllowSpatialization");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bAllowSpatialization(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bAllowSpatialization(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bAllowSpatialization(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bAllowSpatialization = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bAllowSpatialization(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bAllowSpatialization");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bAllowSpatialization", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bAllowSpatialization(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bShouldRemainActiveIfDropped(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bShouldRemainActiveIfDropped(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bShouldRemainActiveIfDropped;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bShouldRemainActiveIfDropped() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bShouldRemainActiveIfDropped");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bShouldRemainActiveIfDropped");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bShouldRemainActiveIfDropped(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bShouldRemainActiveIfDropped(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bShouldRemainActiveIfDropped(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bShouldRemainActiveIfDropped = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bShouldRemainActiveIfDropped(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bShouldRemainActiveIfDropped");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bShouldRemainActiveIfDropped", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bShouldRemainActiveIfDropped(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bStopWhenOwnerDestroyed(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bStopWhenOwnerDestroyed(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bStopWhenOwnerDestroyed;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bStopWhenOwnerDestroyed() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bStopWhenOwnerDestroyed");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bStopWhenOwnerDestroyed");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bStopWhenOwnerDestroyed(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bStopWhenOwnerDestroyed(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bStopWhenOwnerDestroyed(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bStopWhenOwnerDestroyed = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bStopWhenOwnerDestroyed(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bStopWhenOwnerDestroyed");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bStopWhenOwnerDestroyed", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bStopWhenOwnerDestroyed(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bAutoDestroy(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bAutoDestroy(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bAutoDestroy;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bAutoDestroy() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bAutoDestroy");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bAutoDestroy");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bAutoDestroy(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bAutoDestroy(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bAutoDestroy(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bAutoDestroy = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bAutoDestroy(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bAutoDestroy");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bAutoDestroy", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bAutoDestroy(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundClass.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_SoundClassOverride(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::get_SoundClassOverride(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundClass * >( ( (UAudioComponent *) self )->SoundClassOverride )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SoundClassOverride() : unreal.USoundClass {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SoundClassOverride");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SoundClassOverride");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.get_SoundClassOverride(uhx_arg_0)) : unreal.USoundClass );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundClass.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_SoundClassOverride(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_SoundClassOverride(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (UAudioComponent *) self )->SoundClassOverride = ( (USoundClass *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SoundClassOverride(value : unreal.USoundClass) : unreal.USoundClass {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SoundClassOverride");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SoundClassOverride", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.UAudioComponent_Glue.set_SoundClassOverride(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Components/AudioComponent.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_InstanceParameters(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::UAudioComponent_Glue_obj::get_InstanceParameters(unreal::UIntPtr self) {\n\treturn ::uhx::TemplateHelper<TArray<FAudioComponentParam>>::fromPointer( (&(( (UAudioComponent *) self )->InstanceParameters)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_InstanceParameters() : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FAudioComponentParam>>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_InstanceParameters");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "InstanceParameters");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.TArrayImpl.fromPointer( uhx.glues.UAudioComponent_Glue.get_InstanceParameters(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FAudioComponentParam>>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Components/AudioComponent.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_InstanceParameters(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_InstanceParameters(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (UAudioComponent *) self )->InstanceParameters = *::uhx::TemplateHelper< TArray<FAudioComponentParam> >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_InstanceParameters(value : unreal.TArray<unreal.FAudioComponentParam>) : unreal.TArray<unreal.FAudioComponentParam> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_InstanceParameters");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "InstanceParameters", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.UAudioComponent_Glue.set_InstanceParameters(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundBase.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_Sound(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::get_Sound(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundBase * >( ( (UAudioComponent *) self )->Sound )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_Sound() : unreal.USoundBase {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_Sound");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "Sound");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.get_Sound(uhx_arg_0)) : unreal.USoundBase );
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundBase.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_Sound(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_Sound(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (UAudioComponent *) self )->Sound = ( (USoundBase *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_Sound(value : unreal.USoundBase) : unreal.USoundBase {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_Sound");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "Sound", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.UAudioComponent_Glue.set_Sound(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  /**
    
    Set what sound is played by this component
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundBase.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetSound(unreal::UIntPtr self, unreal::UIntPtr NewSound);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetSound(unreal::UIntPtr self, unreal::UIntPtr NewSound) {\n\t( (UAudioComponent *) self )->SetSound(( (USoundBase *) NewSound ));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetSound(NewSound : unreal.USoundBase) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetSound");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetSound", [NewSound]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(NewSound);
    uhx.glues.UAudioComponent_Glue.SetSound(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    This function allows designers to call Play on an Audio Component instance while applying a volume curve over time.
    Parameters allow designers to indicate the duration of the fade, the curve shape, and the start time if seeking into the sound.
    
    @param FadeInDuration How long it should take to reach the FadeVolumeLevel
    @param FadeVolumeLevel The percentage of the AudioComponents's calculated volume to fade to
    @param FadeCurve The curve to use when interpolating between the old and new volume
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void FadeIn(unreal::UIntPtr self, cpp::Float32 FadeInDuration, cpp::Float32 FadeVolumeLevel, cpp::Float32 StartTime, int FadeCurve);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::FadeIn(unreal::UIntPtr self, cpp::Float32 FadeInDuration, cpp::Float32 FadeVolumeLevel, cpp::Float32 StartTime, int FadeCurve) {\n\t( (UAudioComponent *) self )->FadeIn(FadeInDuration, FadeVolumeLevel, StartTime, ( (const EAudioFaderCurve) FadeCurve ));\n}")
  @:haxe.arguments(function(FadeInDuration:unreal.Float32, FadeVolumeLevel:unreal.Float32 = 1.000000, StartTime:unreal.Float32 = 0.000000, FadeCurve:unreal.Const<unreal.EAudioFaderCurve>))
  @:value({ StartTime : 0.000000, FadeVolumeLevel : 1.000000 })
  @:ufunction(BlueprintCallable)
  public function FadeIn(FadeInDuration : cpp.Float32, ?FadeVolumeLevel : cpp.Float32, ?StartTime : cpp.Float32, ?FadeCurve : unreal.Const<unreal.EAudioFaderCurve>) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "FadeIn");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "FadeIn", [FadeInDuration, FadeVolumeLevel, StartTime, FadeCurve]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = FadeInDuration;
    var uhx_arg_2:cpp.Float32 = FadeVolumeLevel != null ? (FadeVolumeLevel) : ((1.000000 : cpp.Float32));
    var uhx_arg_3:cpp.Float32 = StartTime != null ? (StartTime) : ((0.000000 : cpp.Float32));
    var uhx_arg_4:Int = unreal.EAudioFaderCurve.EAudioFaderCurve_EnumConv.unwrap(FadeCurve != null ? (FadeCurve) : ((Linear : unreal.Const<unreal.EAudioFaderCurve>)));
    uhx.glues.UAudioComponent_Glue.FadeIn(uhx_arg_0, uhx_arg_1, uhx_arg_2, uhx_arg_3, uhx_arg_4);
    
    #end
    
  }
  /**
    
    This function allows designers to call a delayed Stop on an Audio Component instance while applying a
    volume curve over time. Parameters allow designers to indicate the duration of the fade and the curve shape.
    
    @param FadeOutDuration how long it should take to reach the FadeVolumeLevel
    @param FadeVolumeLevel the percentage of the AudioComponents's calculated volume in which to fade to
    @param FadeCurve The curve to use when interpolating between the old and new volume
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void FadeOut(unreal::UIntPtr self, cpp::Float32 FadeOutDuration, cpp::Float32 FadeVolumeLevel, int FadeCurve);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::FadeOut(unreal::UIntPtr self, cpp::Float32 FadeOutDuration, cpp::Float32 FadeVolumeLevel, int FadeCurve) {\n\t( (UAudioComponent *) self )->FadeOut(FadeOutDuration, FadeVolumeLevel, ( (const EAudioFaderCurve) FadeCurve ));\n}")
  @:haxe.arguments(function(FadeOutDuration:unreal.Float32, FadeVolumeLevel:unreal.Float32, FadeCurve:unreal.Const<unreal.EAudioFaderCurve>))
  @:ufunction(BlueprintCallable)
  public function FadeOut(FadeOutDuration : cpp.Float32, FadeVolumeLevel : cpp.Float32, ?FadeCurve : unreal.Const<unreal.EAudioFaderCurve>) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "FadeOut");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "FadeOut", [FadeOutDuration, FadeVolumeLevel, FadeCurve]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = FadeOutDuration;
    var uhx_arg_2:cpp.Float32 = FadeVolumeLevel;
    var uhx_arg_3:Int = unreal.EAudioFaderCurve.EAudioFaderCurve_EnumConv.unwrap(FadeCurve != null ? (FadeCurve) : ((Linear : unreal.Const<unreal.EAudioFaderCurve>)));
    uhx.glues.UAudioComponent_Glue.FadeOut(uhx_arg_0, uhx_arg_1, uhx_arg_2, uhx_arg_3);
    
    #end
    
  }
  /**
    
    Begins playing the targeted Audio Componentâ€™s sound at the designated Start Time, seeking into a sound.
    @param StartTime The offset, in seconds, to begin reading the sound at
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void Play(unreal::UIntPtr self, cpp::Float32 StartTime);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::Play(unreal::UIntPtr self, cpp::Float32 StartTime) {\n\t( (UAudioComponent *) self )->Play(StartTime);\n}")
  @:value({ StartTime : 0.000000 })
  @:ufunction(BlueprintCallable)
  public function Play(?StartTime : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "Play");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "Play", [StartTime]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = StartTime != null ? (StartTime) : ((0.000000 : cpp.Float32));
    uhx.glues.UAudioComponent_Glue.Play(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Stop an audio component's sound, issue any delegates if needed
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void Stop(unreal::UIntPtr self);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::Stop(unreal::UIntPtr self) {\n\t( (UAudioComponent *) self )->Stop();\n}")
  @:ufunction(BlueprintCallable)
  public function Stop() : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "Stop");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "Stop", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    uhx.glues.UAudioComponent_Glue.Stop(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Cues request to stop sound after the provided delay (in seconds), stopping immediately if delay is zero or negative
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void StopDelayed(unreal::UIntPtr self, cpp::Float32 DelayTime);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::StopDelayed(unreal::UIntPtr self, cpp::Float32 DelayTime) {\n\t( (UAudioComponent *) self )->StopDelayed(DelayTime);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function StopDelayed(DelayTime : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "StopDelayed");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "StopDelayed", [DelayTime]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = DelayTime;
    uhx.glues.UAudioComponent_Glue.StopDelayed(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Pause an audio component playing its sound cue, issue any delegates if needed
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetPaused(unreal::UIntPtr self, bool bPause);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetPaused(unreal::UIntPtr self, bool bPause) {\n\t( (UAudioComponent *) self )->SetPaused(bPause);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetPaused(bPause : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetPaused");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetPaused", [bPause]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = bPause;
    uhx.glues.UAudioComponent_Glue.SetPaused(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Returns TRUE if the targeted Audio Componentâ€™s sound is playing.
    Doesn't indicate if the sound is paused or fading in/out. Use GetPlayState() to get the full play state.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool IsPlaying(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::IsPlaying(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->IsPlaying();\n}")
  @:ufunction(BlueprintCallable)
  @:thisConst
  public function IsPlaying() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "IsPlaying");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "IsPlaying", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.IsPlaying(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Returns if the sound is virtualized.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool IsVirtualized(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::IsVirtualized(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->IsVirtualized();\n}")
  @:ufunction(BlueprintCallable)
  @:thisConst
  @:final @:nonVirtual 
  public function IsVirtualized() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "IsVirtualized");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "IsVirtualized", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.IsVirtualized(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Returns the enumerated play states of the audio component.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int GetPlayState(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::UAudioComponent_Glue_obj::GetPlayState(unreal::UIntPtr self) {\n\treturn ( (int) (EAudioComponentPlayState) ( (UAudioComponent *) self )->GetPlayState() );\n}")
  @:ufunction(BlueprintCallable)
  @:thisConst
  @:final @:nonVirtual 
  public function GetPlayState() : unreal.EAudioComponentPlayState {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "GetPlayState");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "GetPlayState", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return unreal.EAudioComponentPlayState.EAudioComponentPlayState_EnumConv.wrap(uhx.glues.UAudioComponent_Glue.GetPlayState(uhx_arg_0));
    
    #end
    
  }
  /**
    
    This function allows designers to trigger an adjustment to the sound instanceâ€™s playback Volume with options for smoothly applying a curve over time.
    @param AdjustVolumeDuration The length of time in which to interpolate between the initial volume and the new volume.
    @param AdjustVolumeLevel The new volume to set the Audio Component to.
    @param FadeCurve The curve used when interpolating between the old and new volume.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Classes/Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void AdjustVolume(unreal::UIntPtr self, cpp::Float32 AdjustVolumeDuration, cpp::Float32 AdjustVolumeLevel, int FadeCurve);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::AdjustVolume(unreal::UIntPtr self, cpp::Float32 AdjustVolumeDuration, cpp::Float32 AdjustVolumeLevel, int FadeCurve) {\n\t( (UAudioComponent *) self )->AdjustVolume(AdjustVolumeDuration, AdjustVolumeLevel, ( (const EAudioFaderCurve) FadeCurve ));\n}")
  @:haxe.arguments(function(AdjustVolumeDuration:unreal.Float32, AdjustVolumeLevel:unreal.Float32, FadeCurve:unreal.Const<unreal.EAudioFaderCurve>))
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function AdjustVolume(AdjustVolumeDuration : cpp.Float32, AdjustVolumeLevel : cpp.Float32, ?FadeCurve : unreal.Const<unreal.EAudioFaderCurve>) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "AdjustVolume");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "AdjustVolume", [AdjustVolumeDuration, AdjustVolumeLevel, FadeCurve]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = AdjustVolumeDuration;
    var uhx_arg_2:cpp.Float32 = AdjustVolumeLevel;
    var uhx_arg_3:Int = unreal.EAudioFaderCurve.EAudioFaderCurve_EnumConv.unwrap(FadeCurve != null ? (FadeCurve) : ((Linear : unreal.Const<unreal.EAudioFaderCurve>)));
    uhx.glues.UAudioComponent_Glue.AdjustVolume(uhx_arg_0, uhx_arg_1, uhx_arg_2, uhx_arg_3);
    
    #end
    
  }
  /**
    
    Allows the designer to set the Float Parameter on the SoundCue whose name matches the name indicated.
    @param InName The name of the Float to set. It must match the name set in SoundCue's Crossfade By Param or Continuous Modulator Node.
    @param InFloat The value to set the Parameter to.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetFloatParameter(unreal::UIntPtr self, unreal::VariantPtr InName, cpp::Float32 InFloat);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetFloatParameter(unreal::UIntPtr self, unreal::VariantPtr InName, cpp::Float32 InFloat) {\n\t( (UAudioComponent *) self )->SetFloatParameter(*::uhx::StructHelper< FName >::getPointer(InName), InFloat);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetFloatParameter(InName : unreal.FName, InFloat : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetFloatParameter");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetFloatParameter", [InName, InFloat]);
    
    #else
    if (InName == null) uhx.internal.HaxeHelpers.nullDeref("InName");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = InName;
    var uhx_arg_2:cpp.Float32 = InFloat;
    uhx.glues.UAudioComponent_Glue.SetFloatParameter(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Allows the designer to set the Wave Parameter on the SoundCue whose name matches the name indicated.
    @param InName The name of the Wave to set. It must match the name set in SoundCue's WaveParam Node
    @param InWave The value to set the Parameter to
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h", "Sound/SoundWave.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void SetWaveParameter(unreal::UIntPtr self, unreal::VariantPtr InName, unreal::UIntPtr InWave);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetWaveParameter(unreal::UIntPtr self, unreal::VariantPtr InName, unreal::UIntPtr InWave) {\n\t( (UAudioComponent *) self )->SetWaveParameter(*::uhx::StructHelper< FName >::getPointer(InName), ( (USoundWave *) InWave ));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetWaveParameter(InName : unreal.FName, InWave : unreal.USoundWave) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetWaveParameter");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetWaveParameter", [InName, InWave]);
    
    #else
    if (InName == null) uhx.internal.HaxeHelpers.nullDeref("InName");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = InName;
    var uhx_arg_2:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(InWave);
    uhx.glues.UAudioComponent_Glue.SetWaveParameter(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Allows the designer to set the Boolean Parameter on the SoundCue whose name matches the name indicated.
    @param InName The name of the Boolean to set. It must match the name set in SoundCue's Branch Node
    @param InBool The value to set the Parameter to
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void SetBoolParameter(unreal::UIntPtr self, unreal::VariantPtr InName, bool InBool);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetBoolParameter(unreal::UIntPtr self, unreal::VariantPtr InName, bool InBool) {\n\t( (UAudioComponent *) self )->SetBoolParameter(*::uhx::StructHelper< FName >::getPointer(InName), InBool);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetBoolParameter(InName : unreal.FName, InBool : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetBoolParameter");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetBoolParameter", [InName, InBool]);
    
    #else
    if (InName == null) uhx.internal.HaxeHelpers.nullDeref("InName");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = InName;
    var uhx_arg_2:Bool = InBool;
    uhx.glues.UAudioComponent_Glue.SetBoolParameter(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Allows the designer to set the Integer Parameter on the SoundCue whose name matches the name indicated.
    @param InName The name of the Integer to set. It must match the name set in SoundCue's Switch Node
    @param InInt The value to set the Parameter to
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetIntParameter(unreal::UIntPtr self, unreal::VariantPtr InName, int InInt);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetIntParameter(unreal::UIntPtr self, unreal::VariantPtr InName, int InInt) {\n\t( (UAudioComponent *) self )->SetIntParameter(*::uhx::StructHelper< FName >::getPointer(InName), InInt);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetIntParameter(InName : unreal.FName, InInt : Int) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetIntParameter");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetIntParameter", [InName, InInt]);
    
    #else
    if (InName == null) uhx.internal.HaxeHelpers.nullDeref("InName");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = InName;
    var uhx_arg_2:Int = InInt;
    uhx.glues.UAudioComponent_Glue.SetIntParameter(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Set a new volume multiplier
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetVolumeMultiplier(unreal::UIntPtr self, cpp::Float32 NewVolumeMultiplier);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetVolumeMultiplier(unreal::UIntPtr self, cpp::Float32 NewVolumeMultiplier) {\n\t( (UAudioComponent *) self )->SetVolumeMultiplier(NewVolumeMultiplier);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetVolumeMultiplier(NewVolumeMultiplier : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetVolumeMultiplier");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetVolumeMultiplier", [NewVolumeMultiplier]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = NewVolumeMultiplier;
    uhx.glues.UAudioComponent_Glue.SetVolumeMultiplier(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Set a new pitch multiplier
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetPitchMultiplier(unreal::UIntPtr self, cpp::Float32 NewPitchMultiplier);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetPitchMultiplier(unreal::UIntPtr self, cpp::Float32 NewPitchMultiplier) {\n\t( (UAudioComponent *) self )->SetPitchMultiplier(NewPitchMultiplier);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetPitchMultiplier(NewPitchMultiplier : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetPitchMultiplier");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetPitchMultiplier", [NewPitchMultiplier]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = NewPitchMultiplier;
    uhx.glues.UAudioComponent_Glue.SetPitchMultiplier(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Set whether sounds generated by this audio component should be considered UI sounds
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetUISound(unreal::UIntPtr self, bool bInUISound);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetUISound(unreal::UIntPtr self, bool bInUISound) {\n\t( (UAudioComponent *) self )->SetUISound(bInUISound);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetUISound(bInUISound : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetUISound");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetUISound", [bInUISound]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = bInUISound;
    uhx.glues.UAudioComponent_Glue.SetUISound(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    This function is used to modify the Attenuation Settings on the targeted Audio Component instance. It is worth noting that Attenuation Settings are only passed to new Active Sounds on start, so modified Attenuation data should be set before sound playback.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void AdjustAttenuation(unreal::UIntPtr self, unreal::VariantPtr InAttenuationSettings);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::AdjustAttenuation(unreal::UIntPtr self, unreal::VariantPtr InAttenuationSettings) {\n\t( (UAudioComponent *) self )->AdjustAttenuation(*::uhx::StructHelper< FSoundAttenuationSettings >::getPointer(InAttenuationSettings));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function AdjustAttenuation(InAttenuationSettings : unreal.PRef<unreal.Const<unreal.FSoundAttenuationSettings>>) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "AdjustAttenuation");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "AdjustAttenuation", [InAttenuationSettings]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = InAttenuationSettings;
    uhx.glues.UAudioComponent_Glue.AdjustAttenuation(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Allows designers to target a specific Audio Component instanceâ€™s sound set the send level (volume of sound copied) to the indicated Submix.
    @param Submix The Submix to send the signal to.
    @param SendLevel The scalar used to alter the volume of the copied signal.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundSubmix.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetSubmixSend(unreal::UIntPtr self, unreal::UIntPtr Submix, cpp::Float32 SendLevel);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetSubmixSend(unreal::UIntPtr self, unreal::UIntPtr Submix, cpp::Float32 SendLevel) {\n\t( (UAudioComponent *) self )->SetSubmixSend(( (USoundSubmixBase *) Submix ), SendLevel);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetSubmixSend(Submix : unreal.USoundSubmixBase, SendLevel : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetSubmixSend");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetSubmixSend", [Submix, SendLevel]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(Submix);
    var uhx_arg_2:cpp.Float32 = SendLevel;
    uhx.glues.UAudioComponent_Glue.SetSubmixSend(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Allows designers to target a specific Audio Component instanceâ€™s sound and set the send level (volume of sound copied)
    to the indicated Source Bus. If the Source Bus is not already part of the soundâ€™s sends, the reference will be added to
    this instanceâ€™s Override sends. This particular send occurs before the Source Effect processing chain.
    @param SoundSourceBus The Bus to send the signal to.
    @param SourceBusSendLevel The scalar used to alter the volume of the copied signal.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundSourceBus.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetSourceBusSendPreEffect(unreal::UIntPtr self, unreal::UIntPtr SoundSourceBus, cpp::Float32 SourceBusSendLevel);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetSourceBusSendPreEffect(unreal::UIntPtr self, unreal::UIntPtr SoundSourceBus, cpp::Float32 SourceBusSendLevel) {\n\t( (UAudioComponent *) self )->SetSourceBusSendPreEffect(( (USoundSourceBus *) SoundSourceBus ), SourceBusSendLevel);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetSourceBusSendPreEffect(SoundSourceBus : unreal.USoundSourceBus, SourceBusSendLevel : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetSourceBusSendPreEffect");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetSourceBusSendPreEffect", [SoundSourceBus, SourceBusSendLevel]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(SoundSourceBus);
    var uhx_arg_2:cpp.Float32 = SourceBusSendLevel;
    uhx.glues.UAudioComponent_Glue.SetSourceBusSendPreEffect(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Allows designers to target a specific Audio Component instanceâ€™s sound and set the send level (volume of sound copied)
    to the indicated Source Bus. If the Source Bus is not already part of the soundâ€™s sends, the reference will be added to
    this instanceâ€™s Override sends. This particular send occurs after the Source Effect processing chain.
    @param SoundSourceBus The Bus to send the signal to
    @param SourceBusSendLevel The scalar used to alter the volume of the copied signal
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/SoundSourceBus.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetSourceBusSendPostEffect(unreal::UIntPtr self, unreal::UIntPtr SoundSourceBus, cpp::Float32 SourceBusSendLevel);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetSourceBusSendPostEffect(unreal::UIntPtr self, unreal::UIntPtr SoundSourceBus, cpp::Float32 SourceBusSendLevel) {\n\t( (UAudioComponent *) self )->SetSourceBusSendPostEffect(( (USoundSourceBus *) SoundSourceBus ), SourceBusSendLevel);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetSourceBusSendPostEffect(SoundSourceBus : unreal.USoundSourceBus, SourceBusSendLevel : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetSourceBusSendPostEffect");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetSourceBusSendPostEffect", [SoundSourceBus, SourceBusSendLevel]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(SoundSourceBus);
    var uhx_arg_2:cpp.Float32 = SourceBusSendLevel;
    uhx.glues.UAudioComponent_Glue.SetSourceBusSendPostEffect(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Sets how much audio the sound should send to the given Audio Bus (PRE Source Effects).
    if the Bus Send doesn't already exist, it will be added to the overrides on the active sound.
    @param AudioBus The Bus to send the signal to
    @param AudioBusSendLevel The scalar used to alter the volume of the copied signal
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/AudioBus.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetAudioBusSendPreEffect(unreal::UIntPtr self, unreal::UIntPtr AudioBus, cpp::Float32 AudioBusSendLevel);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetAudioBusSendPreEffect(unreal::UIntPtr self, unreal::UIntPtr AudioBus, cpp::Float32 AudioBusSendLevel) {\n\t( (UAudioComponent *) self )->SetAudioBusSendPreEffect(( (UAudioBus *) AudioBus ), AudioBusSendLevel);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetAudioBusSendPreEffect(AudioBus : unreal.UAudioBus, AudioBusSendLevel : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetAudioBusSendPreEffect");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetAudioBusSendPreEffect", [AudioBus, AudioBusSendLevel]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(AudioBus);
    var uhx_arg_2:cpp.Float32 = AudioBusSendLevel;
    uhx.glues.UAudioComponent_Glue.SetAudioBusSendPreEffect(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Sets how much audio the sound should send to the given Audio Bus (POST Source Effects).
    if the Audio Bus Send doesn't already exist, it will be added to the overrides on the active sound.
    @param AudioBus The Bus to send the signal to
    @param AudioBusSendLevel The scalar used to alter the volume of the copied signal
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "Sound/AudioBus.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetAudioBusSendPostEffect(unreal::UIntPtr self, unreal::UIntPtr AudioBus, cpp::Float32 AudioBusSendLevel);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetAudioBusSendPostEffect(unreal::UIntPtr self, unreal::UIntPtr AudioBus, cpp::Float32 AudioBusSendLevel) {\n\t( (UAudioComponent *) self )->SetAudioBusSendPostEffect(( (UAudioBus *) AudioBus ), AudioBusSendLevel);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetAudioBusSendPostEffect(AudioBus : unreal.UAudioBus, AudioBusSendLevel : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetAudioBusSendPostEffect");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetAudioBusSendPostEffect", [AudioBus, AudioBusSendLevel]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(AudioBus);
    var uhx_arg_2:cpp.Float32 = AudioBusSendLevel;
    uhx.glues.UAudioComponent_Glue.SetAudioBusSendPostEffect(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    When set to TRUE, enables an additional Low Pass Filter Frequency to be calculated in with the
    sound instanceâ€™s LPF total, allowing designers to set filter settings for the targeted Audio Componentâ€™s
    sound instance.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetLowPassFilterEnabled(unreal::UIntPtr self, bool InLowPassFilterEnabled);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetLowPassFilterEnabled(unreal::UIntPtr self, bool InLowPassFilterEnabled) {\n\t( (UAudioComponent *) self )->SetLowPassFilterEnabled(InLowPassFilterEnabled);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetLowPassFilterEnabled(InLowPassFilterEnabled : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetLowPassFilterEnabled");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetLowPassFilterEnabled", [InLowPassFilterEnabled]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = InLowPassFilterEnabled;
    uhx.glues.UAudioComponent_Glue.SetLowPassFilterEnabled(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Sets a cutoff frequency, in Hz, for the targeted Audio Componentâ€™s soundâ€™s Low Pass Filter calculation.
    The lowest cutoff frequency from all of the sound instanceâ€™s possible LPF calculations wins.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetLowPassFilterFrequency(unreal::UIntPtr self, cpp::Float32 InLowPassFilterFrequency);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetLowPassFilterFrequency(unreal::UIntPtr self, cpp::Float32 InLowPassFilterFrequency) {\n\t( (UAudioComponent *) self )->SetLowPassFilterFrequency(InLowPassFilterFrequency);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetLowPassFilterFrequency(InLowPassFilterFrequency : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetLowPassFilterFrequency");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetLowPassFilterFrequency", [InLowPassFilterFrequency]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = InLowPassFilterFrequency;
    uhx.glues.UAudioComponent_Glue.SetLowPassFilterFrequency(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Sets whether or not to output the audio to bus only.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetOutputToBusOnly(unreal::UIntPtr self, bool bInOutputToBusOnly);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::SetOutputToBusOnly(unreal::UIntPtr self, bool bInOutputToBusOnly) {\n\t( (UAudioComponent *) self )->SetOutputToBusOnly(bInOutputToBusOnly);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetOutputToBusOnly(bInOutputToBusOnly : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetOutputToBusOnly");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetOutputToBusOnly", [bInOutputToBusOnly]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = bInOutputToBusOnly;
    uhx.glues.UAudioComponent_Glue.SetOutputToBusOnly(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Queries if the sound wave playing in this audio component has cooked FFT data, returns FALSE if none found.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool HasCookedFFTData(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::HasCookedFFTData(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->HasCookedFFTData();\n}")
  @:ufunction(BlueprintCallable)
  @:thisConst
  @:final @:nonVirtual 
  public function HasCookedFFTData() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "HasCookedFFTData");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "HasCookedFFTData", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.HasCookedFFTData(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Queries whether or not the targeted Audio Component instanceâ€™s sound has Envelope Data, returns FALSE if none found.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool HasCookedAmplitudeEnvelopeData(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::HasCookedAmplitudeEnvelopeData(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->HasCookedAmplitudeEnvelopeData();\n}")
  @:ufunction(BlueprintCallable)
  @:thisConst
  @:final @:nonVirtual 
  public function HasCookedAmplitudeEnvelopeData() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "HasCookedAmplitudeEnvelopeData");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "HasCookedAmplitudeEnvelopeData", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.HasCookedAmplitudeEnvelopeData(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Retrieves the current-time cooked spectral data of the sounds playing on the audio component.
    Spectral data is averaged and interpolated for all playing sounds on this audio component.
    Returns true if there is data and the audio component is playing.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "uhx/glues/TArrayImpl_Glue_UE.h", "Classes/Sound/SoundWave.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static bool GetCookedFFTData(unreal::UIntPtr self, unreal::VariantPtr FrequenciesToGet, unreal::VariantPtr OutSoundWaveSpectralData);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::GetCookedFFTData(unreal::UIntPtr self, unreal::VariantPtr FrequenciesToGet, unreal::VariantPtr OutSoundWaveSpectralData) {\n\treturn ( (UAudioComponent *) self )->GetCookedFFTData(*::uhx::TemplateHelper< TArray<float> >::getPointer(FrequenciesToGet), *::uhx::TemplateHelper< TArray<FSoundWaveSpectralData> >::getPointer(OutSoundWaveSpectralData));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function GetCookedFFTData(FrequenciesToGet : unreal.PRef<unreal.Const<unreal.TArray<unreal.Float32>>>, OutSoundWaveSpectralData : unreal.PRef<unreal.TArray<unreal.FSoundWaveSpectralData>>) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "GetCookedFFTData");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "GetCookedFFTData", [FrequenciesToGet, OutSoundWaveSpectralData]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = FrequenciesToGet;
    var uhx_arg_2:unreal.VariantPtr = OutSoundWaveSpectralData;
    return uhx.glues.UAudioComponent_Glue.GetCookedFFTData(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Retrieves the current-time cooked spectral data of the sounds playing audio component.
    Spectral data is not averaged or interpolated. Instead an array of data with all playing sound waves with cooked data is returned.
    Returns true if there is data and the audio component is playing.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundWave.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static bool GetCookedFFTDataForAllPlayingSounds(unreal::UIntPtr self, unreal::VariantPtr OutSoundWaveSpectralData);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::GetCookedFFTDataForAllPlayingSounds(unreal::UIntPtr self, unreal::VariantPtr OutSoundWaveSpectralData) {\n\treturn ( (UAudioComponent *) self )->GetCookedFFTDataForAllPlayingSounds(*::uhx::TemplateHelper< TArray<FSoundWaveSpectralDataPerSound> >::getPointer(OutSoundWaveSpectralData));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function GetCookedFFTDataForAllPlayingSounds(OutSoundWaveSpectralData : unreal.PRef<unreal.TArray<unreal.FSoundWaveSpectralDataPerSound>>) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "GetCookedFFTDataForAllPlayingSounds");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "GetCookedFFTDataForAllPlayingSounds", [OutSoundWaveSpectralData]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = OutSoundWaveSpectralData;
    return uhx.glues.UAudioComponent_Glue.GetCookedFFTDataForAllPlayingSounds(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Retrieves Cooked Envelope Data at the current playback time. If there are multiple
    SoundWaves playing, data is interpolated and averaged across all playing sound waves.
    Returns FALSE if no data was found.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static bool GetCookedEnvelopeData(unreal::UIntPtr self, cpp::Float32 OutEnvelopeData);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::GetCookedEnvelopeData(unreal::UIntPtr self, cpp::Float32 OutEnvelopeData) {\n\treturn ( (UAudioComponent *) self )->GetCookedEnvelopeData(OutEnvelopeData);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function GetCookedEnvelopeData(OutEnvelopeData : cpp.Float32) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "GetCookedEnvelopeData");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "GetCookedEnvelopeData", [OutEnvelopeData]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = OutEnvelopeData;
    return uhx.glues.UAudioComponent_Glue.GetCookedEnvelopeData(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Retrieves the current-time envelope data of the sounds playing audio component.
    Envelope data is not averaged or interpolated. Instead an array of data with all playing sound waves with cooked data is returned.
    Returns true if there is data and the audio component is playing.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundWave.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static bool GetCookedEnvelopeDataForAllPlayingSounds(unreal::UIntPtr self, unreal::VariantPtr OutEnvelopeData);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::GetCookedEnvelopeDataForAllPlayingSounds(unreal::UIntPtr self, unreal::VariantPtr OutEnvelopeData) {\n\treturn ( (UAudioComponent *) self )->GetCookedEnvelopeDataForAllPlayingSounds(*::uhx::TemplateHelper< TArray<FSoundWaveEnvelopeDataPerSound> >::getPointer(OutEnvelopeData));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function GetCookedEnvelopeDataForAllPlayingSounds(OutEnvelopeData : unreal.PRef<unreal.TArray<unreal.FSoundWaveEnvelopeDataPerSound>>) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "GetCookedEnvelopeDataForAllPlayingSounds");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "GetCookedEnvelopeDataForAllPlayingSounds", [OutEnvelopeData]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = OutEnvelopeData;
    return uhx.glues.UAudioComponent_Glue.GetCookedEnvelopeDataForAllPlayingSounds(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Retrieves Attenuation Settings data on the targeted Audio Component. Returns FALSE if no settings were found.
    Because the Attenuation Settings data structure is copied, FALSE returns will return default values.
    
  **/
  
  @:glueCppIncludes("Components/AudioComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static bool BP_GetAttenuationSettingsToApply(unreal::UIntPtr self, unreal::VariantPtr OutAttenuationSettings);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::BP_GetAttenuationSettingsToApply(unreal::UIntPtr self, unreal::VariantPtr OutAttenuationSettings) {\n\treturn ( (UAudioComponent *) self )->BP_GetAttenuationSettingsToApply(*::uhx::StructHelper< FSoundAttenuationSettings >::getPointer(OutAttenuationSettings));\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function BP_GetAttenuationSettingsToApply(OutAttenuationSettings : unreal.PRef<unreal.FSoundAttenuationSettings>) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "BP_GetAttenuationSettingsToApply");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "BP_GetAttenuationSettingsToApply", [OutAttenuationSettings]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = OutAttenuationSettings;
    return uhx.glues.UAudioComponent_Glue.BP_GetAttenuationSettingsToApply(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bIgnoreForFlushing(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::UAudioComponent_Glue_obj::get_bIgnoreForFlushing(unreal::UIntPtr self) {\n\treturn ( (UAudioComponent *) self )->bIgnoreForFlushing;\n}")
  #if (!UHX_DISPLAY && cppia && !LIVE_RELOAD_BUILD)
  @:deprecated("UHXERR: The field get_bIgnoreForFlushing was not compiled into the latest C++ compilation. Please perform a full C++ compilation.")
  #end
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bIgnoreForFlushing() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bIgnoreForFlushing");
    #end
    #if cppia
    throw "The function get_bIgnoreForFlushing was not compiled into Unreal.hx. C++ recompilation is needed";
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.UAudioComponent_Glue.get_bIgnoreForFlushing(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/AudioComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bIgnoreForFlushing(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::UAudioComponent_Glue_obj::set_bIgnoreForFlushing(unreal::UIntPtr self, bool value) {\n\t( (UAudioComponent *) self )->bIgnoreForFlushing = value;\n}")
  #if (!UHX_DISPLAY && cppia && !LIVE_RELOAD_BUILD)
  @:deprecated("UHXERR: The field set_bIgnoreForFlushing was not compiled into the latest C++ compilation. Please perform a full C++ compilation.")
  #end
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bIgnoreForFlushing(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bIgnoreForFlushing");
    #end
    #if cppia
    throw "The function set_bIgnoreForFlushing was not compiled into Unreal.hx. C++ recompilation is needed";
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.UAudioComponent_Glue.set_bIgnoreForFlushing(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  /**
    
    Returns the `UClass` object which describes this class
    
  **/
  
  @:glueCppIncludes("CoreUObject.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr StaticClass();")
  @:glueCppCode("unreal::UIntPtr uhx::glues::UAudioComponent_Glue_obj::StaticClass() {\n\treturn ( (unreal::UIntPtr) (UAudioComponent::StaticClass()) );\n}")
  @:ifFeature("unreal.UAudioComponent.*")
  public static function StaticClass() : unreal.UClass {
    #if cppia
    return uhx.runtime.UReflectionGenerator.getUClass("AudioComponent");
    
    #else
    return ( cast unreal.UObject.wrap(uhx.glues.UAudioComponent_Glue.StaticClass()) : unreal.UClass );
    
    #end
    
  }
  #end
  
}

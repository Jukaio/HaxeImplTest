// Ver:1
// GeneratedBy:c:\users\jukai\documents\unreal projects\haxetest\plugins\unrealhx/haxe/externs/ue4.27/unreal/frootmotionsource.hx
package unreal;
/**
  
  Generalized source of Root Motion to a CharacterMovementComponent.
  
  Has priorities and different accumulation modes (override, additive, set, ignore).
  
  RootMotionSources are accumulated from highest priority to lowest, once all values
  are "finalized" (meaning no more accumulation to those values), root motion accumulation
  is finished. Having all of translation and rotation in a transform being overridden during
  root motion accumulation means that CharacterMovementComponent Phys*() functions no longer
  need to CalcVelocity() since it'll just get overridden anyway.
  
  Some example source possibilities:
  Full Animation Root Motion (matching only form of root motion we've supported historically):
  - Overrides all translation axes or rotation or both
  - Very High priority so it gets applied first and since it is override no other
  RootMotionSources have an influence that are lower priority
  - Scale on translation and/or rotation is set to 1 to match animation 1 for 1
  - Provides local space transform (character-orientation relative)
  
  - End result: Same as before - overrides velocity/rotation to values in AnimMontage
  - But can now scale individual translation axes if desired, or instead of override
  can use "set" to allow other additive sources of root motion to be applied on top
  of the animation root motion (modify velocity to home root motion melee attacks, etc.)
  
  Jump pad volumes that work during animation root montage attacks
  - Constant velocity modification Z up, additive and high priority
  - Attack/melee animation root motion uses "set" instead of "override" to allow other sources
  - Animation root motion is applied, then the Z up additive of this source is so you are
  affected by the jump pad
  
  Attack/melee homing
  - Additive, lower priority so it gets applied after any animation/significant root motion
  - World space, sourced by logic modifying velocity to go towards nearby enemies
  - Could point to a UAbilityTask node from the GameplayAbilities system
  
  Character movement controlled by splines/curves in-editor instead of requiring animation tweaks
  - Same as animation root motion but source from spline/curve data
  
**/

@:umodule("Unreal")
@:glueCppIncludes("Classes/GameFramework/RootMotionSource.h")
@:uextern
@:ustruct
@:ueGluePath("uhx.glues.FRootMotionSource_Glue")
#if (cppia && !LIVE_RELOAD_BUILD && !macro) @:build(uhx.compiletime.types.CompiledMetaCheck.build("unreal.FRootMotionSource")) #end
@:forward(dispose,isDisposed) abstract FRootMotionSource#if macro (Dynamic) #else (unreal.Struct) to unreal.Struct to unreal.Struct to unreal.VariantPtr #end {
  #if !macro 
  /**
    
    Finish Velocity Parameters
    
  **/
  
  @:uproperty
  public var FinishVelocityParams(get,set):unreal.PPtr<unreal.FRootMotionFinishVelocitySettings>;
  /**
    
    Root Motion generated by this Source
    
  **/
  
  @:uproperty
  public var RootMotionParams(get,set):unreal.PPtr<unreal.FRootMotionMovementParams>;
  /**
    
    True when this RootMotionSource is contributing local space accumulation (false for world space)
    
  **/
  
  @:uproperty
  public var bInLocalSpace(get,set):Bool;
  /**
    
    Settings of this source
    
  **/
  
  @:uproperty
  public var Settings(get,set):unreal.PPtr<unreal.FRootMotionSourceSettings>;
  /**
    
    Status of this source
    
  **/
  
  @:uproperty
  public var Status(get,set):unreal.PPtr<unreal.FRootMotionSourceStatus>;
  /**
    
    The length of this root motion - < 0 for infinite (to be removed manually)
    
  **/
  
  @:uproperty
  public var Duration(get,set):cpp.Float32;
  /**
    
    The last Time entry we had before the last SetTime() - used for simulated catchup
    
  **/
  
  @:uproperty
  public var PreviousTime(get,set):cpp.Float32;
  /**
    
    Time elapsed so far for this source
    
  **/
  
  @:uproperty
  public var CurrentTime(get,set):cpp.Float32;
  /**
    
    Time this source should start (in character movement client time)
    This is used to handle cases of inconsistent tick times (ServerMoves ticking for 1 second when root motion should
    have only applied for the last 0.1 seconds, or root motion source ending halfway through a 0.5 second tick)
    
  **/
  
  @:uproperty
  public var StartTime(get,set):cpp.Float32;
  /**
    
    This name allows us to find the source later so that we can end it.
    
  **/
  
  @:uproperty
  public var InstanceName(get,set):unreal.PPtr<unreal.PPtr<unreal.FName>>;
  /**
    
    Accumulation mode for this source (whether or not to additively apply this root motion or override completely)
    
  **/
  
  @:uproperty
  public var AccumulateMode(get,set):unreal.ERootMotionAccumulateMode;
  /**
    
    ID local to this client or server instance. Used for matching up FRootMotionSources between SavedMoves
    and allow a mapping between server LocalIDs and client LocalIDs for correction/comparison
    
  **/
  
  @:uproperty
  public var LocalID(get,set):cpp.UInt16;
  /**
    
    Priority of this source relative to other sources - higher number being the highest priority/first applied.
    
  **/
  
  @:uproperty
  public var Priority(get,set):cpp.UInt16;
  inline public static function fromPointer(ptr:unreal.VariantPtr):unreal.FRootMotionSource {
    return cast ptr;
  }
  public static function StaticStruct():unreal.UScriptStruct {
    return (uhx_structData != null ? uhx_structData : (uhx_structData = uhx.runtime.UReflectionGenerator.getUStruct("RootMotionSource")));
  }
  
  private static function mkWrapper():unreal.FRootMotionSource {
    return cast uhx.ue.RuntimeLibraryDynamic.createDynamicWrapperFromStruct(@:privateAccess StaticStruct().wrapped);
  }
  public function new() {
    this = mkWrapper();
    var ops = StaticStruct().GetCppStructOps();
    if (!ops.HasZeroConstructor()) ops.Construct(( ( cast this : unreal.VariantPtr).getDynamic() : unreal.Wrapper).getPointer());
  }
  
  @:noCompletion private static var uhx_structData:unreal.UScriptStruct;
  @:noCompletion private inline function get_structData():unreal.UScriptStruct {
    return StaticStruct();
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_FinishVelocityParams(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::get_FinishVelocityParams(unreal::VariantPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(::uhx::StructHelper< FRootMotionSource >::getPointer(self)->FinishVelocityParams)) );\n}")
  @:uproperty
  private function get_FinishVelocityParams() : unreal.PPtr<unreal.FRootMotionFinishVelocitySettings> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_FinishVelocityParams");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "FinishVelocityParams");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FRootMotionFinishVelocitySettings.fromPointer( uhx.glues.FRootMotionSource_Glue.get_FinishVelocityParams(uhx_arg_0) ) : unreal.PPtr<unreal.FRootMotionFinishVelocitySettings> );
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void set_FinishVelocityParams(unreal::VariantPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_FinishVelocityParams(unreal::VariantPtr self, unreal::VariantPtr value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->FinishVelocityParams = *::uhx::StructHelper< FRootMotionFinishVelocitySettings >::getPointer(value);\n}")
  @:uproperty
  private function set_FinishVelocityParams(value : unreal.FRootMotionFinishVelocitySettings) : unreal.FRootMotionFinishVelocitySettings {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_FinishVelocityParams");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "FinishVelocityParams", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.FRootMotionSource_Glue.set_FinishVelocityParams(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h", "Classes/Animation/AnimationAsset.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_RootMotionParams(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::get_RootMotionParams(unreal::VariantPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(::uhx::StructHelper< FRootMotionSource >::getPointer(self)->RootMotionParams)) );\n}")
  @:uproperty
  private function get_RootMotionParams() : unreal.PPtr<unreal.FRootMotionMovementParams> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_RootMotionParams");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "RootMotionParams");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FRootMotionMovementParams.fromPointer( uhx.glues.FRootMotionSource_Glue.get_RootMotionParams(uhx_arg_0) ) : unreal.PPtr<unreal.FRootMotionMovementParams> );
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h", "Classes/Animation/AnimationAsset.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void set_RootMotionParams(unreal::VariantPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_RootMotionParams(unreal::VariantPtr self, unreal::VariantPtr value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->RootMotionParams = *::uhx::StructHelper< FRootMotionMovementParams >::getPointer(value);\n}")
  @:uproperty
  private function set_RootMotionParams(value : unreal.FRootMotionMovementParams) : unreal.FRootMotionMovementParams {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_RootMotionParams");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "RootMotionParams", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.FRootMotionSource_Glue.set_RootMotionParams(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static bool get_bInLocalSpace(unreal::VariantPtr self);")
  @:glueCppCode("bool uhx::glues::FRootMotionSource_Glue_obj::get_bInLocalSpace(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->bInLocalSpace;\n}")
  @:uproperty
  private function get_bInLocalSpace() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_bInLocalSpace");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "bInLocalSpace");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_bInLocalSpace(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void set_bInLocalSpace(unreal::VariantPtr self, bool value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_bInLocalSpace(unreal::VariantPtr self, bool value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->bInLocalSpace = value;\n}")
  @:uproperty
  private function set_bInLocalSpace(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_bInLocalSpace");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "bInLocalSpace", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:Bool = value;
    uhx.glues.FRootMotionSource_Glue.set_bInLocalSpace(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_Settings(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::get_Settings(unreal::VariantPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Settings)) );\n}")
  @:uproperty
  private function get_Settings() : unreal.PPtr<unreal.FRootMotionSourceSettings> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_Settings");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "Settings");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FRootMotionSourceSettings.fromPointer( uhx.glues.FRootMotionSource_Glue.get_Settings(uhx_arg_0) ) : unreal.PPtr<unreal.FRootMotionSourceSettings> );
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void set_Settings(unreal::VariantPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_Settings(unreal::VariantPtr self, unreal::VariantPtr value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Settings = *::uhx::StructHelper< FRootMotionSourceSettings >::getPointer(value);\n}")
  @:uproperty
  private function set_Settings(value : unreal.FRootMotionSourceSettings) : unreal.FRootMotionSourceSettings {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_Settings");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "Settings", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.FRootMotionSource_Glue.set_Settings(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_Status(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::get_Status(unreal::VariantPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Status)) );\n}")
  @:uproperty
  private function get_Status() : unreal.PPtr<unreal.FRootMotionSourceStatus> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_Status");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "Status");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FRootMotionSourceStatus.fromPointer( uhx.glues.FRootMotionSource_Glue.get_Status(uhx_arg_0) ) : unreal.PPtr<unreal.FRootMotionSourceStatus> );
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void set_Status(unreal::VariantPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_Status(unreal::VariantPtr self, unreal::VariantPtr value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Status = *::uhx::StructHelper< FRootMotionSourceStatus >::getPointer(value);\n}")
  @:uproperty
  private function set_Status(value : unreal.FRootMotionSourceStatus) : unreal.FRootMotionSourceStatus {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_Status");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "Status", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.FRootMotionSource_Glue.set_Status(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_Duration(unreal::VariantPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::FRootMotionSource_Glue_obj::get_Duration(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Duration;\n}")
  @:uproperty
  private function get_Duration() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_Duration");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "Duration");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_Duration(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_Duration(unreal::VariantPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_Duration(unreal::VariantPtr self, cpp::Float32 value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Duration = value;\n}")
  @:uproperty
  private function set_Duration(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_Duration");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "Duration", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.FRootMotionSource_Glue.set_Duration(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_PreviousTime(unreal::VariantPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::FRootMotionSource_Glue_obj::get_PreviousTime(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->PreviousTime;\n}")
  @:uproperty
  private function get_PreviousTime() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_PreviousTime");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "PreviousTime");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_PreviousTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_PreviousTime(unreal::VariantPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_PreviousTime(unreal::VariantPtr self, cpp::Float32 value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->PreviousTime = value;\n}")
  @:uproperty
  private function set_PreviousTime(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_PreviousTime");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "PreviousTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.FRootMotionSource_Glue.set_PreviousTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_CurrentTime(unreal::VariantPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::FRootMotionSource_Glue_obj::get_CurrentTime(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->CurrentTime;\n}")
  @:uproperty
  private function get_CurrentTime() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_CurrentTime");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "CurrentTime");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_CurrentTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_CurrentTime(unreal::VariantPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_CurrentTime(unreal::VariantPtr self, cpp::Float32 value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->CurrentTime = value;\n}")
  @:uproperty
  private function set_CurrentTime(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_CurrentTime");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "CurrentTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.FRootMotionSource_Glue.set_CurrentTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::Float32 get_StartTime(unreal::VariantPtr self);")
  @:glueCppCode("cpp::Float32 uhx::glues::FRootMotionSource_Glue_obj::get_StartTime(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->StartTime;\n}")
  @:uproperty
  private function get_StartTime() : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_StartTime");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "StartTime");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_StartTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_StartTime(unreal::VariantPtr self, cpp::Float32 value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_StartTime(unreal::VariantPtr self, cpp::Float32 value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->StartTime = value;\n}")
  @:uproperty
  private function set_StartTime(value : cpp.Float32) : cpp.Float32 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_StartTime");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "StartTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:cpp.Float32 = value;
    uhx.glues.FRootMotionSource_Glue.set_StartTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_InstanceName(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::get_InstanceName(unreal::VariantPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(::uhx::StructHelper< FRootMotionSource >::getPointer(self)->InstanceName)) );\n}")
  @:uproperty
  private function get_InstanceName() : unreal.PPtr<unreal.PPtr<unreal.FName>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_InstanceName");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "InstanceName");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FNameImpl.fromPointer( uhx.glues.FRootMotionSource_Glue.get_InstanceName(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.FName>> );
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h", "UObject/NameTypes.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void set_InstanceName(unreal::VariantPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_InstanceName(unreal::VariantPtr self, unreal::VariantPtr value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->InstanceName = *::uhx::StructHelper< FName >::getPointer(value);\n}")
  @:uproperty
  private function set_InstanceName(value : unreal.FName) : unreal.FName {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_InstanceName");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "InstanceName", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.FRootMotionSource_Glue.set_InstanceName(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_AccumulateMode(unreal::VariantPtr self);")
  @:glueCppCode("int uhx::glues::FRootMotionSource_Glue_obj::get_AccumulateMode(unreal::VariantPtr self) {\n\treturn ( (int) (ERootMotionAccumulateMode) ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->AccumulateMode );\n}")
  @:uproperty
  private function get_AccumulateMode() : unreal.ERootMotionAccumulateMode {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_AccumulateMode");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "AccumulateMode");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return unreal.ERootMotionAccumulateMode.ERootMotionAccumulateMode_EnumConv.wrap(uhx.glues.FRootMotionSource_Glue.get_AccumulateMode(uhx_arg_0));
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_AccumulateMode(unreal::VariantPtr self, int value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_AccumulateMode(unreal::VariantPtr self, int value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->AccumulateMode = ( (ERootMotionAccumulateMode) value );\n}")
  @:uproperty
  private function set_AccumulateMode(value : unreal.ERootMotionAccumulateMode) : unreal.ERootMotionAccumulateMode {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_AccumulateMode");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "AccumulateMode", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:Int = unreal.ERootMotionAccumulateMode.ERootMotionAccumulateMode_EnumConv.unwrap(value);
    uhx.glues.FRootMotionSource_Glue.set_AccumulateMode(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::UInt16 get_LocalID(unreal::VariantPtr self);")
  @:glueCppCode("cpp::UInt16 uhx::glues::FRootMotionSource_Glue_obj::get_LocalID(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->LocalID;\n}")
  @:uproperty
  private function get_LocalID() : cpp.UInt16 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_LocalID");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "LocalID");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_LocalID(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_LocalID(unreal::VariantPtr self, cpp::UInt16 value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_LocalID(unreal::VariantPtr self, cpp::UInt16 value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->LocalID = value;\n}")
  @:uproperty
  private function set_LocalID(value : cpp.UInt16) : cpp.UInt16 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_LocalID");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "LocalID", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:cpp.UInt16 = value;
    uhx.glues.FRootMotionSource_Glue.set_LocalID(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static cpp::UInt16 get_Priority(unreal::VariantPtr self);")
  @:glueCppCode("cpp::UInt16 uhx::glues::FRootMotionSource_Glue_obj::get_Priority(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Priority;\n}")
  @:uproperty
  private function get_Priority() : cpp.UInt16 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "get_Priority");
    #end
    #if cppia
    return unreal.ReflectAPI.structGetField(this, uhx_structData, "Priority");
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return uhx.glues.FRootMotionSource_Glue.get_Priority(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_Priority(unreal::VariantPtr self, cpp::UInt16 value);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::set_Priority(unreal::VariantPtr self, cpp::UInt16 value) {\n\t::uhx::StructHelper< FRootMotionSource >::getPointer(self)->Priority = value;\n}")
  @:uproperty
  private function set_Priority(value : cpp.UInt16) : cpp.UInt16 {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "set_Priority");
    #end
    #if cppia
    unreal.ReflectAPI.structSetField(this, uhx_structData, "Priority", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:cpp.UInt16 = value;
    uhx.glues.FRootMotionSource_Glue.set_Priority(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  /**
    
    Invokes the copy constructor of the referenced C++ class.
    This has some limitations - it won't copy the full inheritance chain of the class if it wasn't typed as the exact class
    it will also be a compilation error if the wrapped class forbids the C++ copy constructor;
    in this case, the extern class definition should contain the `@:noCopy` metadata
    
  **/
  
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr copyNew(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::copyNew(unreal::VariantPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (new FRootMotionSource(*::uhx::StructHelper< FRootMotionSource >::getPointer(self))) );\n}")
  #if (!UHX_DISPLAY && cppia && !LIVE_RELOAD_BUILD)
  @:deprecated("UHXERR: The field copyNew was not compiled into the latest C++ compilation. Please perform a full C++ compilation.")
  #end
  public function copyNew() : unreal.PPtr<unreal.POwnedPtr<unreal.FRootMotionSource>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "copyNew");
    #end
    #if cppia
    throw "The function copyNew was not compiled into Unreal.hx. C++ recompilation is needed";
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FRootMotionSource.fromPointer( uhx.glues.FRootMotionSource_Glue.copyNew(uhx_arg_0) ) : unreal.PPtr<unreal.POwnedPtr<unreal.FRootMotionSource>> );
    
    #end
    
  }
  /**
    
    Invokes the copy constructor of the referenced C++ class.
    This has some limitations - it won't copy the full inheritance chain of the class if it wasn't typed as the exact class
    it will also be a compilation error if the wrapped class forbids the C++ copy constructor;
    in this case, the extern class definition should contain the `@:noCopy` metadata
    
  **/
  
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr copy(unreal::VariantPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::FRootMotionSource_Glue_obj::copy(unreal::VariantPtr self) {\n\treturn ::uhx::StructHelper<FRootMotionSource>::fromStruct((*::uhx::StructHelper< FRootMotionSource >::getPointer(self)));\n}")
  #if (!UHX_DISPLAY && cppia && !LIVE_RELOAD_BUILD)
  @:deprecated("UHXERR: The field copy was not compiled into the latest C++ compilation. Please perform a full C++ compilation.")
  #end
  public function copy() : unreal.FRootMotionSource {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "copy");
    #end
    #if cppia
    throw "The function copy was not compiled into Unreal.hx. C++ recompilation is needed";
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    return ( @:privateAccess unreal.FRootMotionSource.fromPointer( uhx.glues.FRootMotionSource_Glue.copy(uhx_arg_0) ) : unreal.FRootMotionSource );
    
    #end
    
  }
  /**
    
    Assigns the value of `val` to this structure
  **/
  
  @:glueCppIncludes("uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static void assign(unreal::VariantPtr self, unreal::VariantPtr val);")
  @:glueCppCode("void uhx::glues::FRootMotionSource_Glue_obj::assign(unreal::VariantPtr self, unreal::VariantPtr val) {\n\tuhx::TypeTraits::Assign<FRootMotionSource>::doAssign(*::uhx::StructHelper< FRootMotionSource >::getPointer(self), *::uhx::StructHelper< FRootMotionSource >::getPointer(val));\n}")
  #if (!UHX_DISPLAY && cppia && !LIVE_RELOAD_BUILD)
  @:deprecated("UHXERR: The field assign was not compiled into the latest C++ compilation. Please perform a full C++ compilation.")
  #end
  public function assign(val : unreal.FRootMotionSource) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkPointer(this, "assign");
    #end
    #if cppia
    throw "The function assign was not compiled into Unreal.hx. C++ recompilation is needed";
    #else
    if (val == null) uhx.internal.HaxeHelpers.nullDeref("val");
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = val;
    uhx.glues.FRootMotionSource_Glue.assign(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  @:glueCppIncludes("<uhx/TypeTraits.h>", "uhx/Wrapper.h", "Classes/GameFramework/RootMotionSource.h")
  @:glueHeaderIncludes("VariantPtr.h")
  @:glueHeaderCode("static bool equals(unreal::VariantPtr self, unreal::VariantPtr other);")
  @:glueCppCode("bool uhx::glues::FRootMotionSource_Glue_obj::equals(unreal::VariantPtr self, unreal::VariantPtr other) {\n\tif (self == other) { return true; }if (self.isNull() || other.isNull()) { return false; }return uhx::TypeTraits::Equals<FRootMotionSource>::isEq(*::uhx::StructHelper< FRootMotionSource >::getPointer(self), *::uhx::StructHelper< FRootMotionSource >::getPointer(other));\n}")
  #if (!UHX_DISPLAY && cppia && !LIVE_RELOAD_BUILD)
  @:deprecated("UHXERR: The field equals was not compiled into the latest C++ compilation. Please perform a full C++ compilation.")
  #end
  @:op(A == B)
  public function equals(other : unreal.PPtr<unreal.FRootMotionSource>) : Bool {
    #if cppia
    throw "The function equals was not compiled into Unreal.hx. C++ recompilation is needed";
    #else
    var uhx_arg_0:unreal.VariantPtr = this;
    var uhx_arg_1:unreal.VariantPtr = other;
    return uhx.glues.FRootMotionSource_Glue.equals(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  #end
  
}

// Ver:1
// GeneratedBy:c:\users\jukai\documents\unreal projects\haxetest\plugins\unrealhx/haxe/externs/ue4.27/unreal/audiomixer/usynthcomponent.hx
package unreal.audiomixer;
@:umodule("AudioMixer")
@:glueCppIncludes("Components/SynthComponent.h")
@:uextern
@:uclass
@:ueGluePath("uhx.glues.USynthComponent_Glue")
#if (cppia && !LIVE_RELOAD_BUILD && !macro) @:build(uhx.compiletime.types.CompiledMetaCheck.build("unreal.audiomixer.USynthComponent")) #end
class USynthComponent #if !macro extends unreal.USceneComponent #end {
  #if !macro 
  @:uproperty
  public var OnAudioEnvelopeValue(get,set):unreal.PPtr<unreal.audiomixer.FOnSynthEnvelopeValue>;
  /**
    
    The release time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the
    envelope value of sounds played with this audio component. Only used in audio mixer.
    
  **/
  
  @:uproperty
  public var EnvelopeFollowerReleaseTime(get,set):Int;
  /**
    
    The attack time in milliseconds for the envelope follower. Delegate callbacks can be registered to get the
    envelope value of sounds played with this audio component. Only used in audio mixer.
    
  **/
  
  @:uproperty
  public var EnvelopeFollowerAttackTime(get,set):Int;
  /**
    
    Whether or not this synth is playing as a preview sound
    
  **/
  
  @:uproperty
  public var bIsPreviewSound(get,set):Bool;
  /**
    
    Whether or not this sound plays when the game is paused in the UI
    
  **/
  
  @:uproperty
  public var bIsUISound(get,set):Bool;
  /**
    
    This sound will send its audio output to this list of buses if there are bus instances playing before source effects are processed.
    
  **/
  
  @:uproperty
  public var PreEffectBusSends(get,set):unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSourceBusSendInfo>>>;
  /**
    
    This sound will send its audio output to this list of buses if there are bus instances playing after source effects are processed.
    
  **/
  
  @:uproperty
  public var BusSends(get,set):unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSourceBusSendInfo>>>;
  /**
    
    An array of submix sends. Audio from this sound will send a portion of its audio to these effects.
    
  **/
  
  @:uproperty
  public var SoundSubmixSends(get,set):unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSubmixSendInfo>>>;
  /**
    
    Submix this sound belongs to
    
  **/
  
  @:uproperty
  public var SoundSubmix(get,set):unreal.USoundSubmixBase;
  /**
    
    The source effect chain to use for this sound.
    
  **/
  
  @:uproperty
  public var SourceEffectChain(get,set):unreal.USoundEffectSourcePresetChain;
  /**
    
    Sound class this sound belongs to
    
  **/
  
  @:uproperty
  public var SoundClass(get,set):unreal.USoundClass;
  /**
    
    What sound concurrency to use for sounds generated by this audio component
    
  **/
  
  @:uproperty
  public var ConcurrencySet(get,set):unreal.PPtr<unreal.TSet<unreal.USoundConcurrency>>;
  /**
    
    What sound concurrency to use for sounds generated by this audio component
    
  **/
  
  @:deprecated
  @:uproperty
  public var ConcurrencySettings_DEPRECATED(get,set):unreal.USoundConcurrency;
  /**
    
    If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component
    
  **/
  
  @:uproperty
  public var AttenuationOverrides(get,set):unreal.PPtr<unreal.FSoundAttenuationSettings>;
  /**
    
    If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component
    
  **/
  
  @:uproperty
  public var AttenuationSettings(get,set):unreal.USoundAttenuation;
  /**
    
    Whether or not to enable Submix Sends other than the Base Submix.
    
  **/
  
  @:uproperty
  public var bEnableSubmixSends(get,set):Bool;
  /**
    
    If enabled, sound will route to the Master Submix by default or to the Base Submix if defined. If disabled, sound will route ONLY to the Submix Sends and/or Bus Sends
    
  **/
  
  @:uproperty
  public var bEnableBaseSubmix(get,set):Bool;
  /**
    
    Whether or not to enable sending this audio's output to buses.
    
  **/
  
  @:uproperty
  public var bEnableBusSends(get,set):Bool;
  /**
    
    Whether or not to only send this audio's output to a bus. If true, this sound will not be audible except through bus sends.
    
  **/
  
  @:deprecated
  @:uproperty
  public var bOutputToBusOnly_DEPRECATED(get,set):Bool;
  /**
    
    Should the Attenuation Settings asset be used (false) or should the properties set directly on the component be used for attenuation properties
    
  **/
  
  @:uproperty
  public var bOverrideAttenuation(get,set):Bool;
  /**
    
    Is this audio component allowed to be spatialized?
    
  **/
  
  @:uproperty
  public var bAllowSpatialization(get,set):Bool;
  /**
    
    Stop sound when owner is destroyed
    
  **/
  
  @:uproperty
  public var bStopWhenOwnerDestroyed(get,set):Bool;
  /**
    
    Auto destroy this component on completion
    
  **/
  
  @:uproperty
  public var bAutoDestroy(get,set):Bool;
  static function __init__():Void {
    #if !cppia
    var func = cpp.Function.fromStaticFunction(wrapPointer).toFunction();
    uhx.ue.ClassMap.addWrapper(uhx.glues.USynthComponent_Glue.StaticClass(), func);
    #else
    uhx.runtime.Helpers.addCppiaExternWrapper("SynthComponent", "unreal.audiomixer.USynthComponent");
    #end
  }
  
  #if !cppia
  static function wrapPointer(uobject:unreal.UIntPtr):unreal.UIntPtr {
    return uhx.internal.HaxeHelpers.dynamicToPointer(new unreal.audiomixer.USynthComponent(uobject));
  }
  #end
  inline public static function wrap(uobject:unreal.UIntPtr):unreal.audiomixer.USynthComponent {
    return cast uhx.ClassWrap.wrap(uobject);
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Public/Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_OnAudioEnvelopeValue(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::USynthComponent_Glue_obj::get_OnAudioEnvelopeValue(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (USynthComponent *) self )->OnAudioEnvelopeValue)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_OnAudioEnvelopeValue() : unreal.PPtr<unreal.audiomixer.FOnSynthEnvelopeValue> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_OnAudioEnvelopeValue");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "OnAudioEnvelopeValue");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.audiomixer.FOnSynthEnvelopeValue.fromPointer( uhx.glues.USynthComponent_Glue.get_OnAudioEnvelopeValue(uhx_arg_0) ) : unreal.PPtr<unreal.audiomixer.FOnSynthEnvelopeValue> );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Public/Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_OnAudioEnvelopeValue(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_OnAudioEnvelopeValue(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (USynthComponent *) self )->OnAudioEnvelopeValue = *::uhx::StructHelper< FOnSynthEnvelopeValue >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_OnAudioEnvelopeValue(value : unreal.audiomixer.FOnSynthEnvelopeValue) : unreal.audiomixer.FOnSynthEnvelopeValue {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_OnAudioEnvelopeValue");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "OnAudioEnvelopeValue", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.USynthComponent_Glue.set_OnAudioEnvelopeValue(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_EnvelopeFollowerReleaseTime(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::USynthComponent_Glue_obj::get_EnvelopeFollowerReleaseTime(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->EnvelopeFollowerReleaseTime;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_EnvelopeFollowerReleaseTime() : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_EnvelopeFollowerReleaseTime");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "EnvelopeFollowerReleaseTime");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_EnvelopeFollowerReleaseTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_EnvelopeFollowerReleaseTime(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_EnvelopeFollowerReleaseTime(unreal::UIntPtr self, int value) {\n\t( (USynthComponent *) self )->EnvelopeFollowerReleaseTime = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_EnvelopeFollowerReleaseTime(value : Int) : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_EnvelopeFollowerReleaseTime");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "EnvelopeFollowerReleaseTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = value;
    uhx.glues.USynthComponent_Glue.set_EnvelopeFollowerReleaseTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static int get_EnvelopeFollowerAttackTime(unreal::UIntPtr self);")
  @:glueCppCode("int uhx::glues::USynthComponent_Glue_obj::get_EnvelopeFollowerAttackTime(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->EnvelopeFollowerAttackTime;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_EnvelopeFollowerAttackTime() : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_EnvelopeFollowerAttackTime");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "EnvelopeFollowerAttackTime");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_EnvelopeFollowerAttackTime(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void set_EnvelopeFollowerAttackTime(unreal::UIntPtr self, int value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_EnvelopeFollowerAttackTime(unreal::UIntPtr self, int value) {\n\t( (USynthComponent *) self )->EnvelopeFollowerAttackTime = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_EnvelopeFollowerAttackTime(value : Int) : Int {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_EnvelopeFollowerAttackTime");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "EnvelopeFollowerAttackTime", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Int = value;
    uhx.glues.USynthComponent_Glue.set_EnvelopeFollowerAttackTime(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bIsPreviewSound(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bIsPreviewSound(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bIsPreviewSound;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bIsPreviewSound() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bIsPreviewSound");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bIsPreviewSound");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bIsPreviewSound(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bIsPreviewSound(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bIsPreviewSound(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bIsPreviewSound = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bIsPreviewSound(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bIsPreviewSound");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bIsPreviewSound", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bIsPreviewSound(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bIsUISound(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bIsUISound(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bIsUISound;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bIsUISound() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bIsUISound");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bIsUISound");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bIsUISound(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bIsUISound(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bIsUISound(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bIsUISound = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bIsUISound(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bIsUISound");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bIsUISound", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bIsUISound(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundSourceBusSend.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_PreEffectBusSends(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::USynthComponent_Glue_obj::get_PreEffectBusSends(unreal::UIntPtr self) {\n\treturn ::uhx::TemplateHelper<TArray<FSoundSourceBusSendInfo>>::fromPointer( (&(( (USynthComponent *) self )->PreEffectBusSends)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_PreEffectBusSends() : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSourceBusSendInfo>>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_PreEffectBusSends");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "PreEffectBusSends");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.TArrayImpl.fromPointer( uhx.glues.USynthComponent_Glue.get_PreEffectBusSends(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSourceBusSendInfo>>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundSourceBusSend.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_PreEffectBusSends(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_PreEffectBusSends(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (USynthComponent *) self )->PreEffectBusSends = *::uhx::TemplateHelper< TArray<FSoundSourceBusSendInfo> >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_PreEffectBusSends(value : unreal.TArray<unreal.FSoundSourceBusSendInfo>) : unreal.TArray<unreal.FSoundSourceBusSendInfo> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_PreEffectBusSends");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "PreEffectBusSends", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.USynthComponent_Glue.set_PreEffectBusSends(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundSourceBusSend.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_BusSends(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::USynthComponent_Glue_obj::get_BusSends(unreal::UIntPtr self) {\n\treturn ::uhx::TemplateHelper<TArray<FSoundSourceBusSendInfo>>::fromPointer( (&(( (USynthComponent *) self )->BusSends)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_BusSends() : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSourceBusSendInfo>>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_BusSends");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "BusSends");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.TArrayImpl.fromPointer( uhx.glues.USynthComponent_Glue.get_BusSends(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSourceBusSendInfo>>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundSourceBusSend.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_BusSends(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_BusSends(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (USynthComponent *) self )->BusSends = *::uhx::TemplateHelper< TArray<FSoundSourceBusSendInfo> >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_BusSends(value : unreal.TArray<unreal.FSoundSourceBusSendInfo>) : unreal.TArray<unreal.FSoundSourceBusSendInfo> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_BusSends");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "BusSends", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.USynthComponent_Glue.set_BusSends(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundSubmixSend.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_SoundSubmixSends(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::USynthComponent_Glue_obj::get_SoundSubmixSends(unreal::UIntPtr self) {\n\treturn ::uhx::TemplateHelper<TArray<FSoundSubmixSendInfo>>::fromPointer( (&(( (USynthComponent *) self )->SoundSubmixSends)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SoundSubmixSends() : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSubmixSendInfo>>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SoundSubmixSends");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SoundSubmixSends");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.TArrayImpl.fromPointer( uhx.glues.USynthComponent_Glue.get_SoundSubmixSends(uhx_arg_0) ) : unreal.PPtr<unreal.PPtr<unreal.TArray<unreal.FSoundSubmixSendInfo>>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Array.h", "Classes/Sound/SoundSubmixSend.h", "uhx/glues/TArrayImpl_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_SoundSubmixSends(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_SoundSubmixSends(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (USynthComponent *) self )->SoundSubmixSends = *::uhx::TemplateHelper< TArray<FSoundSubmixSendInfo> >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SoundSubmixSends(value : unreal.TArray<unreal.FSoundSubmixSendInfo>) : unreal.TArray<unreal.FSoundSubmixSendInfo> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SoundSubmixSends");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SoundSubmixSends", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.USynthComponent_Glue.set_SoundSubmixSends(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundSubmix.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_SoundSubmix(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::USynthComponent_Glue_obj::get_SoundSubmix(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundSubmixBase * >( ( (USynthComponent *) self )->SoundSubmix )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SoundSubmix() : unreal.USoundSubmixBase {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SoundSubmix");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SoundSubmix");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.USynthComponent_Glue.get_SoundSubmix(uhx_arg_0)) : unreal.USoundSubmixBase );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundSubmix.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_SoundSubmix(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_SoundSubmix(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (USynthComponent *) self )->SoundSubmix = ( (USoundSubmixBase *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SoundSubmix(value : unreal.USoundSubmixBase) : unreal.USoundSubmixBase {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SoundSubmix");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SoundSubmix", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.USynthComponent_Glue.set_SoundSubmix(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundEffectSource.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_SourceEffectChain(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::USynthComponent_Glue_obj::get_SourceEffectChain(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundEffectSourcePresetChain * >( ( (USynthComponent *) self )->SourceEffectChain )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SourceEffectChain() : unreal.USoundEffectSourcePresetChain {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SourceEffectChain");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SourceEffectChain");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.USynthComponent_Glue.get_SourceEffectChain(uhx_arg_0)) : unreal.USoundEffectSourcePresetChain );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundEffectSource.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_SourceEffectChain(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_SourceEffectChain(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (USynthComponent *) self )->SourceEffectChain = ( (USoundEffectSourcePresetChain *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SourceEffectChain(value : unreal.USoundEffectSourcePresetChain) : unreal.USoundEffectSourcePresetChain {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SourceEffectChain");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SourceEffectChain", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.USynthComponent_Glue.set_SourceEffectChain(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundClass.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_SoundClass(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::USynthComponent_Glue_obj::get_SoundClass(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundClass * >( ( (USynthComponent *) self )->SoundClass )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_SoundClass() : unreal.USoundClass {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_SoundClass");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "SoundClass");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.USynthComponent_Glue.get_SoundClass(uhx_arg_0)) : unreal.USoundClass );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundClass.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_SoundClass(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_SoundClass(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (USynthComponent *) self )->SoundClass = ( (USoundClass *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_SoundClass(value : unreal.USoundClass) : unreal.USoundClass {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_SoundClass");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "SoundClass", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.USynthComponent_Glue.set_SoundClass(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Set.h", "Sound/SoundConcurrency.h", "uhx/glues/TSet_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_ConcurrencySet(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::USynthComponent_Glue_obj::get_ConcurrencySet(unreal::UIntPtr self) {\n\treturn ::uhx::TemplateHelper<TSet<USoundConcurrency *>>::fromPointer( (&(( (USynthComponent *) self )->ConcurrencySet)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_ConcurrencySet() : unreal.PPtr<unreal.TSet<unreal.USoundConcurrency>> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_ConcurrencySet");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "ConcurrencySet");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.TSet.fromPointer( uhx.glues.USynthComponent_Glue.get_ConcurrencySet(uhx_arg_0) ) : unreal.PPtr<unreal.TSet<unreal.USoundConcurrency>> );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Containers/Set.h", "Sound/SoundConcurrency.h", "uhx/glues/TSet_Glue_UE.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_ConcurrencySet(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_ConcurrencySet(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (USynthComponent *) self )->ConcurrencySet = *::uhx::TemplateHelper< TSet<USoundConcurrency *> >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_ConcurrencySet(value : unreal.TSet<unreal.USoundConcurrency>) : unreal.TSet<unreal.USoundConcurrency> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_ConcurrencySet");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "ConcurrencySet", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.USynthComponent_Glue.set_ConcurrencySet(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundConcurrency.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::USynthComponent_Glue_obj::get_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundConcurrency * >( ( (USynthComponent *) self )->ConcurrencySettings_DEPRECATED )) );\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_ConcurrencySettings_DEPRECATED() : unreal.USoundConcurrency {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_ConcurrencySettings_DEPRECATED");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "ConcurrencySettings_DEPRECATED");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.USynthComponent_Glue.get_ConcurrencySettings_DEPRECATED(uhx_arg_0)) : unreal.USoundConcurrency );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundConcurrency.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_ConcurrencySettings_DEPRECATED(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (USynthComponent *) self )->ConcurrencySettings_DEPRECATED = ( (USoundConcurrency *) value );\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_ConcurrencySettings_DEPRECATED(value : unreal.USoundConcurrency) : unreal.USoundConcurrency {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_ConcurrencySettings_DEPRECATED");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "ConcurrencySettings_DEPRECATED", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.USynthComponent_Glue.set_ConcurrencySettings_DEPRECATED(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static unreal::VariantPtr get_AttenuationOverrides(unreal::UIntPtr self);")
  @:glueCppCode("unreal::VariantPtr uhx::glues::USynthComponent_Glue_obj::get_AttenuationOverrides(unreal::UIntPtr self) {\n\treturn unreal::VariantPtr::fromExternalPointer( (void *) (&(( (USynthComponent *) self )->AttenuationOverrides)) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AttenuationOverrides() : unreal.PPtr<unreal.FSoundAttenuationSettings> {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AttenuationOverrides");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AttenuationOverrides");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( @:privateAccess unreal.FSoundAttenuationSettings.fromPointer( uhx.glues.USynthComponent_Glue.get_AttenuationOverrides(uhx_arg_0) ) : unreal.PPtr<unreal.FSoundAttenuationSettings> );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "uhx/Wrapper.h", "Classes/Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h", "VariantPtr.h")
  @:glueHeaderCode("static void set_AttenuationOverrides(unreal::UIntPtr self, unreal::VariantPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_AttenuationOverrides(unreal::UIntPtr self, unreal::VariantPtr value) {\n\t( (USynthComponent *) self )->AttenuationOverrides = *::uhx::StructHelper< FSoundAttenuationSettings >::getPointer(value);\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AttenuationOverrides(value : unreal.FSoundAttenuationSettings) : unreal.FSoundAttenuationSettings {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AttenuationOverrides");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AttenuationOverrides", value);
    return value;
    
    #else
    if (value == null) uhx.internal.HaxeHelpers.nullDeref("value");
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.VariantPtr = value;
    uhx.glues.USynthComponent_Glue.set_AttenuationOverrides(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr get_AttenuationSettings(unreal::UIntPtr self);")
  @:glueCppCode("unreal::UIntPtr uhx::glues::USynthComponent_Glue_obj::get_AttenuationSettings(unreal::UIntPtr self) {\n\treturn ( (unreal::UIntPtr) (const_cast< USoundAttenuation * >( ( (USynthComponent *) self )->AttenuationSettings )) );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_AttenuationSettings() : unreal.USoundAttenuation {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_AttenuationSettings");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "AttenuationSettings");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return ( cast unreal.UObject.wrap(uhx.glues.USynthComponent_Glue.get_AttenuationSettings(uhx_arg_0)) : unreal.USoundAttenuation );
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundAttenuation.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_AttenuationSettings(unreal::UIntPtr self, unreal::UIntPtr value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_AttenuationSettings(unreal::UIntPtr self, unreal::UIntPtr value) {\n\t( (USynthComponent *) self )->AttenuationSettings = ( (USoundAttenuation *) value );\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_AttenuationSettings(value : unreal.USoundAttenuation) : unreal.USoundAttenuation {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_AttenuationSettings");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "AttenuationSettings", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(value);
    uhx.glues.USynthComponent_Glue.set_AttenuationSettings(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bEnableSubmixSends(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bEnableSubmixSends(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bEnableSubmixSends;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bEnableSubmixSends() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bEnableSubmixSends");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bEnableSubmixSends");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bEnableSubmixSends(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bEnableSubmixSends(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bEnableSubmixSends(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bEnableSubmixSends = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bEnableSubmixSends(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bEnableSubmixSends");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bEnableSubmixSends", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bEnableSubmixSends(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bEnableBaseSubmix(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bEnableBaseSubmix(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bEnableBaseSubmix;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bEnableBaseSubmix() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bEnableBaseSubmix");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bEnableBaseSubmix");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bEnableBaseSubmix(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bEnableBaseSubmix(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bEnableBaseSubmix(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bEnableBaseSubmix = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bEnableBaseSubmix(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bEnableBaseSubmix");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bEnableBaseSubmix", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bEnableBaseSubmix(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bEnableBusSends(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bEnableBusSends(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bEnableBusSends;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bEnableBusSends() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bEnableBusSends");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bEnableBusSends");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bEnableBusSends(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bEnableBusSends(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bEnableBusSends(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bEnableBusSends = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bEnableBusSends(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bEnableBusSends");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bEnableBusSends", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bEnableBusSends(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bOutputToBusOnly_DEPRECATED(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bOutputToBusOnly_DEPRECATED(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bOutputToBusOnly_DEPRECATED;\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bOutputToBusOnly_DEPRECATED() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bOutputToBusOnly_DEPRECATED");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bOutputToBusOnly_DEPRECATED");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bOutputToBusOnly_DEPRECATED(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bOutputToBusOnly_DEPRECATED(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bOutputToBusOnly_DEPRECATED(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bOutputToBusOnly_DEPRECATED = value;\n}")
  @:deprecated
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bOutputToBusOnly_DEPRECATED(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bOutputToBusOnly_DEPRECATED");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bOutputToBusOnly_DEPRECATED", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bOutputToBusOnly_DEPRECATED(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bOverrideAttenuation(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bOverrideAttenuation(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bOverrideAttenuation;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bOverrideAttenuation() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bOverrideAttenuation");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bOverrideAttenuation");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bOverrideAttenuation(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bOverrideAttenuation(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bOverrideAttenuation(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bOverrideAttenuation = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bOverrideAttenuation(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bOverrideAttenuation");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bOverrideAttenuation", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bOverrideAttenuation(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bAllowSpatialization(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bAllowSpatialization(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bAllowSpatialization;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bAllowSpatialization() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bAllowSpatialization");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bAllowSpatialization");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bAllowSpatialization(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bAllowSpatialization(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bAllowSpatialization(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bAllowSpatialization = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bAllowSpatialization(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bAllowSpatialization");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bAllowSpatialization", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bAllowSpatialization(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bStopWhenOwnerDestroyed(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bStopWhenOwnerDestroyed(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bStopWhenOwnerDestroyed;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bStopWhenOwnerDestroyed() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bStopWhenOwnerDestroyed");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bStopWhenOwnerDestroyed");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bStopWhenOwnerDestroyed(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bStopWhenOwnerDestroyed(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bStopWhenOwnerDestroyed(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bStopWhenOwnerDestroyed = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bStopWhenOwnerDestroyed(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bStopWhenOwnerDestroyed");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bStopWhenOwnerDestroyed", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bStopWhenOwnerDestroyed(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool get_bAutoDestroy(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::get_bAutoDestroy(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->bAutoDestroy;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  private function get_bAutoDestroy() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "get_bAutoDestroy");
    #end
    #if cppia
    return unreal.ReflectAPI.bpGetField(this, "bAutoDestroy");
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.get_bAutoDestroy(uhx_arg_0);
    
    #end
    
  }
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void set_bAutoDestroy(unreal::UIntPtr self, bool value);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::set_bAutoDestroy(unreal::UIntPtr self, bool value) {\n\t( (USynthComponent *) self )->bAutoDestroy = value;\n}")
  @:uproperty
  @:final @:nonVirtual 
  @:nonVirtual
  @:final @:nonVirtual 
  @:nonVirtual
  private function set_bAutoDestroy(value : Bool) : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "set_bAutoDestroy");
    #end
    #if cppia
    unreal.ReflectAPI.bpSetField(this, "bAutoDestroy", value);
    return value;
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = value;
    uhx.glues.USynthComponent_Glue.set_bAutoDestroy(uhx_arg_0, uhx_arg_1);
    return value;
    
    #end
    
  }
  /**
    
    Starts the synth generating audio.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void Start(unreal::UIntPtr self);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::Start(unreal::UIntPtr self) {\n\t( (USynthComponent *) self )->Start();\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function Start() : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "Start");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "Start", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    uhx.glues.USynthComponent_Glue.Start(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Stops the synth generating audio.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void Stop(unreal::UIntPtr self);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::Stop(unreal::UIntPtr self) {\n\t( (USynthComponent *) self )->Stop();\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function Stop() : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "Stop");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "Stop", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    uhx.glues.USynthComponent_Glue.Stop(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Returns true if this component is currently playing.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static bool IsPlaying(unreal::UIntPtr self);")
  @:glueCppCode("bool uhx::glues::USynthComponent_Glue_obj::IsPlaying(unreal::UIntPtr self) {\n\treturn ( (USynthComponent *) self )->IsPlaying();\n}")
  @:ufunction(BlueprintCallable)
  @:thisConst
  @:final @:nonVirtual 
  public function IsPlaying() : Bool {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "IsPlaying");
    #end
    #if cppia
    return unreal.ReflectAPI.callMethod(this, "IsPlaying", null);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    return uhx.glues.USynthComponent_Glue.IsPlaying(uhx_arg_0);
    
    #end
    
  }
  /**
    
    Set a new volume multiplier
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetVolumeMultiplier(unreal::UIntPtr self, cpp::Float32 VolumeMultiplier);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::SetVolumeMultiplier(unreal::UIntPtr self, cpp::Float32 VolumeMultiplier) {\n\t( (USynthComponent *) self )->SetVolumeMultiplier(VolumeMultiplier);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetVolumeMultiplier(VolumeMultiplier : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetVolumeMultiplier");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetVolumeMultiplier", [VolumeMultiplier]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = VolumeMultiplier;
    uhx.glues.USynthComponent_Glue.SetVolumeMultiplier(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Sets how much audio the sound should send to the given submix.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h", "Sound/SoundSubmix.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetSubmixSend(unreal::UIntPtr self, unreal::UIntPtr Submix, cpp::Float32 SendLevel);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::SetSubmixSend(unreal::UIntPtr self, unreal::UIntPtr Submix, cpp::Float32 SendLevel) {\n\t( (USynthComponent *) self )->SetSubmixSend(( (USoundSubmixBase *) Submix ), SendLevel);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetSubmixSend(Submix : unreal.USoundSubmixBase, SendLevel : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetSubmixSend");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetSubmixSend", [Submix, SendLevel]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(Submix);
    var uhx_arg_2:cpp.Float32 = SendLevel;
    uhx.glues.USynthComponent_Glue.SetSubmixSend(uhx_arg_0, uhx_arg_1, uhx_arg_2);
    
    #end
    
  }
  /**
    
    Sets whether or not the low pass filter is enabled on the audio component.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetLowPassFilterEnabled(unreal::UIntPtr self, bool InLowPassFilterEnabled);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::SetLowPassFilterEnabled(unreal::UIntPtr self, bool InLowPassFilterEnabled) {\n\t( (USynthComponent *) self )->SetLowPassFilterEnabled(InLowPassFilterEnabled);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetLowPassFilterEnabled(InLowPassFilterEnabled : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetLowPassFilterEnabled");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetLowPassFilterEnabled", [InLowPassFilterEnabled]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = InLowPassFilterEnabled;
    uhx.glues.USynthComponent_Glue.SetLowPassFilterEnabled(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Sets lowpass filter frequency of the audio component.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h", "<hxcpp.h>")
  @:glueHeaderCode("static void SetLowPassFilterFrequency(unreal::UIntPtr self, cpp::Float32 InLowPassFilterFrequency);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::SetLowPassFilterFrequency(unreal::UIntPtr self, cpp::Float32 InLowPassFilterFrequency) {\n\t( (USynthComponent *) self )->SetLowPassFilterFrequency(InLowPassFilterFrequency);\n}")
  @:ufunction(BlueprintCallable)
  public function SetLowPassFilterFrequency(InLowPassFilterFrequency : cpp.Float32) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetLowPassFilterFrequency");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetLowPassFilterFrequency", [InLowPassFilterFrequency]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:cpp.Float32 = InLowPassFilterFrequency;
    uhx.glues.USynthComponent_Glue.SetLowPassFilterFrequency(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Sets whether or not the synth component outputs its audio to any source or audio buses.
    
  **/
  
  @:glueCppIncludes("Components/SynthComponent.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static void SetOutputToBusOnly(unreal::UIntPtr self, bool bInOutputToBusOnly);")
  @:glueCppCode("void uhx::glues::USynthComponent_Glue_obj::SetOutputToBusOnly(unreal::UIntPtr self, bool bInOutputToBusOnly) {\n\t( (USynthComponent *) self )->SetOutputToBusOnly(bInOutputToBusOnly);\n}")
  @:ufunction(BlueprintCallable)
  @:final @:nonVirtual 
  public function SetOutputToBusOnly(bInOutputToBusOnly : Bool) : Void {
    #if (debug || UHX_CHECK_POINTER)
    uhx.internal.HaxeHelpers.checkObjectPointer(this, "SetOutputToBusOnly");
    #end
    #if cppia
    unreal.ReflectAPI.callMethod(this, "SetOutputToBusOnly", [bInOutputToBusOnly]);
    
    #else
    var uhx_arg_0:unreal.UIntPtr = uhx.internal.HaxeHelpers.getUObjectWrapped(this);
    var uhx_arg_1:Bool = bInOutputToBusOnly;
    uhx.glues.USynthComponent_Glue.SetOutputToBusOnly(uhx_arg_0, uhx_arg_1);
    
    #end
    
  }
  /**
    
    Returns the `UClass` object which describes this class
    
  **/
  
  @:glueCppIncludes("CoreUObject.h")
  @:glueHeaderIncludes("IntPtr.h")
  @:glueHeaderCode("static unreal::UIntPtr StaticClass();")
  @:glueCppCode("unreal::UIntPtr uhx::glues::USynthComponent_Glue_obj::StaticClass() {\n\treturn ( (unreal::UIntPtr) (USynthComponent::StaticClass()) );\n}")
  @:ifFeature("unreal.audiomixer.USynthComponent.*")
  public static function StaticClass() : unreal.UClass {
    #if cppia
    return uhx.runtime.UReflectionGenerator.getUClass("SynthComponent");
    
    #else
    return ( cast unreal.UObject.wrap(uhx.glues.USynthComponent_Glue.StaticClass()) : unreal.UClass );
    
    #end
    
  }
  #end
  
}

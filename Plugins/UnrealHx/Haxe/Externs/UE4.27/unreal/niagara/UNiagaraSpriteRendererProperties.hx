/**
 * 
 * WARNING! This file was autogenerated by: 
 *  _   _ _   _ __   __ 
 * | | | | | | |\ \ / / 
 * | | | | |_| | \ V /  
 * | | | |  _  | /   \  
 * | |_| | | | |/ /^\ \ 
 *  \___/\_| |_/\/   \/ 
 * 
 * This file was autogenerated by UnrealHxGenerator using UHT definitions.
 * It only includes UPROPERTYs and UFUNCTIONs. Do not modify it!
 * In order to add more definitions, create or edit a type with the same name/package, but with an `_Extra` suffix
**/
package unreal.niagara;

@:umodule("Niagara")
@:glueCppIncludes("NiagaraSpriteRendererProperties.h")
@:uextern @:uclass extern class UNiagaraSpriteRendererProperties extends unreal.niagara.UNiagaraRendererProperties {
  #if WITH_EDITORONLY_DATA
  
  /**
    Alpha channel values larger than the threshold are considered occupied and will be contained in the bounding geometry.
    Raising this threshold slightly can reduce overdraw in particles using this animation asset.
  **/
  @:uproperty public var AlphaThreshold : unreal.Float32;
  @:uproperty public var OpacitySourceMode : unreal.EOpacitySourceMode;
  
  /**
    More bounding vertices results in reduced overdraw, but adds more triangle overhead.
    The eight vertex mode is best used when the SubUV texture has a lot of space to cut out that is not captured by the four vertex version,
    and when the particles using the texture will be few and large.
  **/
  @:uproperty public var BoundingMode : unreal.ESubUVBoundingVertexCount;
  
  /**
    Texture to generate bounding geometry from.
  **/
  @:uproperty public var CutoutTexture : unreal.UTexture2D;
  
  /**
    Use the cutout texture from the material opacity mask, or if none exist, from the material opacity.
  **/
  @:uproperty public var bUseMaterialCutoutTexture : Bool;
  #end // WITH_EDITORONLY_DATA
  @:uproperty public var PrevPivotOffsetBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  @:uproperty public var PrevCameraOffsetBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  @:uproperty public var PrevSpriteAlignmentBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  @:uproperty public var PrevSpriteFacingBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  @:uproperty public var PrevSpriteSizeBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  @:uproperty public var PrevSpriteRotationBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  @:uproperty public var PrevVelocityBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    The following bindings are only needed for accurate motion vectors
  **/
  @:uproperty public var PrevPositionBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    If this array has entries, we will create a MaterialInstanceDynamic per Emitter instance from Material and set the Material parameters using the Niagara simulation variables listed.
  **/
  @:uproperty public var MaterialParameterBindings : unreal.TArray<unreal.niagara.FNiagaraMaterialAttributeBinding>;
  
  /**
    Which attribute should we use for RendererVisibilityTag?
  **/
  @:uproperty public var RendererVisibilityTagBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for Normalized Age?
  **/
  @:uproperty public var NormalizedAgeBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for custom sorting? Defaults to Particles.NormalizedAge.
  **/
  @:uproperty public var CustomSortingBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for material randoms when generating sprites?
  **/
  @:uproperty public var MaterialRandomBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for pivot offset? (NOTE: Values are expected to be in UV space).
  **/
  @:uproperty public var PivotOffsetBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for UV scale when generating sprites?
  **/
  @:uproperty public var UVScaleBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for camera offset when generating sprites?
  **/
  @:uproperty public var CameraOffsetBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for dynamic material parameters when generating sprites?
  **/
  @:uproperty public var DynamicMaterial3Binding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for dynamic material parameters when generating sprites?
  **/
  @:uproperty public var DynamicMaterial2Binding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for dynamic material parameters when generating sprites?
  **/
  @:uproperty public var DynamicMaterial1Binding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for dynamic material parameters when generating sprites?
  **/
  @:uproperty public var DynamicMaterialBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for sprite sub-image indexing when generating sprites?
  **/
  @:uproperty public var SubImageIndexBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for sprite alignment when generating sprites?
  **/
  @:uproperty public var SpriteAlignmentBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for sprite facing when generating sprites?
  **/
  @:uproperty public var SpriteFacingBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for sprite size when generating sprites?
  **/
  @:uproperty public var SpriteSizeBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for sprite rotation (in degrees) when generating sprites?
  **/
  @:uproperty public var SpriteRotationBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for velocity when generating sprites?
  **/
  @:uproperty public var VelocityBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for color when generating sprites?
  **/
  @:uproperty public var ColorBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    Which attribute should we use for position when generating sprites?
  **/
  @:uproperty public var PositionBinding : unreal.niagara.FNiagaraVariableAttributeBinding;
  
  /**
    If a render visibility tag is present, particles whose tag matches this value will be visible in this renderer.
  **/
  @:uproperty public var RendererVisibility : unreal.FakeUInt32;
  @:uproperty public var MaxCameraDistance : unreal.Float32;
  @:uproperty public var MinCameraDistance : unreal.Float32;
  
  /**
    Enables frustum culling of individual sprites
  **/
  @:uproperty public var bEnableCameraDistanceCulling : Bool;
  
  /**
    When FacingMode is FacingCameraDistanceBlend, the distance at which the sprite is fully facing the camera position
  **/
  @:uproperty public var MaxFacingCameraBlendDistance : unreal.Float32;
  
  /**
    When FacingMode is FacingCameraDistanceBlend, the distance at which the sprite is fully facing the camera plane.
  **/
  @:uproperty public var MinFacingCameraBlendDistance : unreal.Float32;
  
  /**
    If true and a GPU emitter, we will use the current frames data to render with regardless of where the batcher may execute the dispatches.
    If you have other emitters that are not translucent and using data that forces it to be a frame latent (i.e. view uniform buffer) you may need to disable
    on renderers with translucent materials if you need the frame they are reading to match exactly.
  **/
  @:uproperty public var bGpuLowLatencyTranslucency : Bool;
  
  /**
    If true, the particles are only sorted when using a translucent material.
  **/
  @:uproperty public var bSortOnlyWhenTranslucent : Bool;
  
  /**
    If true, removes the HMD view roll (e.g. in VR)
  **/
  @:uproperty public var bRemoveHMDRollInVR : Bool;
  
  /**
    If true, blends the sub-image UV lookup with its next adjacent member using the fractional part of the SubImageIndex float value as the linear interpolation factor.
  **/
  @:uproperty public var bSubImageBlend : Bool;
  
  /**
    When using SubImage lookups for particles, this variable contains the number of columns in X and the number of rows in Y.
  **/
  @:uproperty public var SubImageSize : unreal.FVector2D;
  
  /**
    Determines how we sort the particles prior to rendering.
  **/
  @:uproperty public var SortMode : unreal.niagara.ENiagaraSortMode;
  
  /**
    Determines the location of the pivot point of this particle. It follows Unreal's UV space, which has the upper left of the image at 0,0 and bottom right at 1,1. The middle is at 0.5, 0.5.
    NOTE: This value is ignored if "Pivot Offset Binding" is bound to a valid attribute
  **/
  @:uproperty public var PivotInUVSpace : unreal.FVector2D;
  
  /**
    Determines how the particle billboard orients itself relative to the camera.
  **/
  @:uproperty public var FacingMode : unreal.niagara.ENiagaraSpriteFacingMode;
  
  /**
    Imagine the particle texture having an arrow pointing up, these modes define how the particle aligns that texture to other particle attributes.
  **/
  @:uproperty public var Alignment : unreal.niagara.ENiagaraSpriteAlignment;
  
  /**
    Use the UMaterialInterface bound to this user variable if it is set to a valid value. If this is bound to a valid value and Material is also set, UserParamBinding wins.
  **/
  @:uproperty public var MaterialUserParamBinding : unreal.niagara.FNiagaraUserParameterBinding;
  
  /**
    Whether or not to draw a single element for the Emitter or to draw the particles.
  **/
  @:uproperty public var SourceMode : unreal.niagara.ENiagaraRendererSourceDataMode;
  
  /**
    The material used to render the particle. Note that it must have the Use with Niagara Sprites flag checked.
  **/
  @:uproperty public var Material : unreal.UMaterialInterface;
  
}

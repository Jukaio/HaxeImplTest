// Ver:1
// GeneratedBy:c:\users\jukai\documents\unreal projects\haxetest\plugins\unrealhx/haxe/externs/ue4.27/unreal/ukismetmathlibrary.hx
/*******************************************************
 * 
 * WARNING! This file was autogenerated by: 
 *  _    _                      _   _ 
 * | |  | |                    | | | |
 * | |  | |_ __  _ __ ___  __ _| | | |__ __  __
 * | |  | | '_ \| '__/ _ \/ _` | | | '_ \ \/ /
 * | |__| | | | | | |  __/ (_| | |_| | | |>  < 
 *  \____/|_| |_|_|  \___|\__,_|_(_)_| |_/_/\_\
 *******************************************************/


package uhx.glues;
@:unrealGlue extern class UKismetMathLibrary_Glue {
public static function RandomBool():Bool;
public static function RandomBoolWithWeight(Weight:cpp.Float32):Bool;
public static function RandomBoolWithWeightFromStream(Weight:cpp.Float32, RandomStream:unreal.VariantPtr):Bool;
public static function Not_PreBool(A:Bool):Bool;
public static function EqualEqual_BoolBool(A:Bool, B:Bool):Bool;
public static function NotEqual_BoolBool(A:Bool, B:Bool):Bool;
public static function BooleanAND(A:Bool, B:Bool):Bool;
public static function BooleanNAND(A:Bool, B:Bool):Bool;
public static function BooleanOR(A:Bool, B:Bool):Bool;
public static function BooleanXOR(A:Bool, B:Bool):Bool;
public static function BooleanNOR(A:Bool, B:Bool):Bool;
public static function Multiply_ByteByte(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function Divide_ByteByte(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function Percent_ByteByte(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function Add_ByteByte(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function Subtract_ByteByte(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function BMin(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function BMax(A:cpp.UInt8, B:cpp.UInt8):cpp.UInt8;
public static function Less_ByteByte(A:cpp.UInt8, B:cpp.UInt8):Bool;
public static function Greater_ByteByte(A:cpp.UInt8, B:cpp.UInt8):Bool;
public static function LessEqual_ByteByte(A:cpp.UInt8, B:cpp.UInt8):Bool;
public static function GreaterEqual_ByteByte(A:cpp.UInt8, B:cpp.UInt8):Bool;
public static function EqualEqual_ByteByte(A:cpp.UInt8, B:cpp.UInt8):Bool;
public static function NotEqual_ByteByte(A:cpp.UInt8, B:cpp.UInt8):Bool;
public static function Multiply_IntInt(A:Int, B:Int):Int;
public static function Divide_IntInt(A:Int, B:Int):Int;
public static function Percent_IntInt(A:Int, B:Int):Int;
public static function Add_IntInt(A:Int, B:Int):Int;
public static function Subtract_IntInt(A:Int, B:Int):Int;
public static function Less_IntInt(A:Int, B:Int):Bool;
public static function Greater_IntInt(A:Int, B:Int):Bool;
public static function LessEqual_IntInt(A:Int, B:Int):Bool;
public static function GreaterEqual_IntInt(A:Int, B:Int):Bool;
public static function EqualEqual_IntInt(A:Int, B:Int):Bool;
public static function NotEqual_IntInt(A:Int, B:Int):Bool;
public static function InRange_IntInt(Value:Int, Min:Int, Max:Int, InclusiveMin:Bool, InclusiveMax:Bool):Bool;
public static function And_IntInt(A:Int, B:Int):Int;
public static function Xor_IntInt(A:Int, B:Int):Int;
public static function Or_IntInt(A:Int, B:Int):Int;
public static function Not_Int(A:Int):Int;
public static function SignOfInteger(A:Int):Int;
public static function RandomInteger(Max:Int):Int;
public static function RandomIntegerInRange(Min:Int, Max:Int):Int;
public static function Min(A:Int, B:Int):Int;
public static function Max(A:Int, B:Int):Int;
public static function Clamp(Value:Int, Min:Int, Max:Int):Int;
public static function Wrap(Value:Int, Min:Int, Max:Int):Int;
public static function Abs_Int(A:Int):Int;
public static function Multiply_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Divide_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Add_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Subtract_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Less_Int64Int64(A:unreal.Int64, B:unreal.Int64):Bool;
public static function Greater_Int64Int64(A:unreal.Int64, B:unreal.Int64):Bool;
public static function LessEqual_Int64Int64(A:unreal.Int64, B:unreal.Int64):Bool;
public static function GreaterEqual_Int64Int64(A:unreal.Int64, B:unreal.Int64):Bool;
public static function EqualEqual_Int64Int64(A:unreal.Int64, B:unreal.Int64):Bool;
public static function NotEqual_Int64Int64(A:unreal.Int64, B:unreal.Int64):Bool;
public static function InRange_Int64Int64(Value:unreal.Int64, Min:unreal.Int64, Max:unreal.Int64, InclusiveMin:Bool, InclusiveMax:Bool):Bool;
public static function And_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Xor_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Or_Int64Int64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function Not_Int64(A:unreal.Int64):unreal.Int64;
public static function SignOfInteger64(A:unreal.Int64):unreal.Int64;
public static function RandomInteger64(Max:unreal.Int64):unreal.Int64;
public static function RandomInteger64InRange(Min:unreal.Int64, Max:unreal.Int64):unreal.Int64;
public static function MinInt64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function MaxInt64(A:unreal.Int64, B:unreal.Int64):unreal.Int64;
public static function ClampInt64(Value:unreal.Int64, Min:unreal.Int64, Max:unreal.Int64):unreal.Int64;
public static function Abs_Int64(A:unreal.Int64):unreal.Int64;
public static function MultiplyMultiply_FloatFloat(Base:cpp.Float32, Exp:cpp.Float32):cpp.Float32;
public static function Multiply_FloatFloat(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function Multiply_IntFloat(A:Int, B:cpp.Float32):cpp.Float32;
public static function Divide_FloatFloat(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function Percent_FloatFloat(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function Fraction(A:cpp.Float32):cpp.Float32;
public static function Add_FloatFloat(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function Subtract_FloatFloat(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function Less_FloatFloat(A:cpp.Float32, B:cpp.Float32):Bool;
public static function Greater_FloatFloat(A:cpp.Float32, B:cpp.Float32):Bool;
public static function LessEqual_FloatFloat(A:cpp.Float32, B:cpp.Float32):Bool;
public static function GreaterEqual_FloatFloat(A:cpp.Float32, B:cpp.Float32):Bool;
public static function EqualEqual_FloatFloat(A:cpp.Float32, B:cpp.Float32):Bool;
public static function NearlyEqual_FloatFloat(A:cpp.Float32, B:cpp.Float32, ErrorTolerance:cpp.Float32):Bool;
public static function NotEqual_FloatFloat(A:cpp.Float32, B:cpp.Float32):Bool;
public static function InRange_FloatFloat(Value:cpp.Float32, Min:cpp.Float32, Max:cpp.Float32, InclusiveMin:Bool, InclusiveMax:Bool):Bool;
public static function Hypotenuse(Width:cpp.Float32, Height:cpp.Float32):cpp.Float32;
public static function GridSnap_Float(Location:cpp.Float32, GridSize:cpp.Float32):cpp.Float32;
public static function Abs(A:cpp.Float32):cpp.Float32;
public static function Sin(A:cpp.Float32):cpp.Float32;
public static function Asin(A:cpp.Float32):cpp.Float32;
public static function Cos(A:cpp.Float32):cpp.Float32;
public static function Acos(A:cpp.Float32):cpp.Float32;
public static function Tan(A:cpp.Float32):cpp.Float32;
public static function Atan(A:cpp.Float32):cpp.Float32;
public static function Atan2(Y:cpp.Float32, X:cpp.Float32):cpp.Float32;
public static function Exp(A:cpp.Float32):cpp.Float32;
public static function Log(A:cpp.Float32, Base:cpp.Float32):cpp.Float32;
public static function Loge(A:cpp.Float32):cpp.Float32;
public static function Sqrt(A:cpp.Float32):cpp.Float32;
public static function Square(A:cpp.Float32):cpp.Float32;
public static function RandomFloat():cpp.Float32;
public static function RandomFloatInRange(Min:cpp.Float32, Max:cpp.Float32):cpp.Float32;
public static function GetPI():cpp.Float32;
public static function GetTAU():cpp.Float32;
public static function DegreesToRadians(A:cpp.Float32):cpp.Float32;
public static function RadiansToDegrees(A:cpp.Float32):cpp.Float32;
public static function DegSin(A:cpp.Float32):cpp.Float32;
public static function DegAsin(A:cpp.Float32):cpp.Float32;
public static function DegCos(A:cpp.Float32):cpp.Float32;
public static function DegAcos(A:cpp.Float32):cpp.Float32;
public static function DegTan(A:cpp.Float32):cpp.Float32;
public static function DegAtan(A:cpp.Float32):cpp.Float32;
public static function DegAtan2(Y:cpp.Float32, X:cpp.Float32):cpp.Float32;
public static function ClampAngle(AngleDegrees:cpp.Float32, MinAngleDegrees:cpp.Float32, MaxAngleDegrees:cpp.Float32):cpp.Float32;
public static function FMin(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function FMax(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function FClamp(Value:cpp.Float32, Min:cpp.Float32, Max:cpp.Float32):cpp.Float32;
public static function FWrap(Value:cpp.Float32, Min:cpp.Float32, Max:cpp.Float32):cpp.Float32;
public static function SafeDivide(A:cpp.Float32, B:cpp.Float32):cpp.Float32;
public static function MaxOfIntArray(IntArray:unreal.VariantPtr, IndexOfMaxValue:Int, MaxValue:Int):Void;
public static function MinOfIntArray(IntArray:unreal.VariantPtr, IndexOfMinValue:Int, MinValue:Int):Void;
public static function MaxOfFloatArray(FloatArray:unreal.VariantPtr, IndexOfMaxValue:Int, MaxValue:cpp.Float32):Void;
public static function MinOfFloatArray(FloatArray:unreal.VariantPtr, IndexOfMinValue:Int, MinValue:cpp.Float32):Void;
public static function MaxOfByteArray(ByteArray:unreal.VariantPtr, IndexOfMaxValue:Int, MaxValue:cpp.UInt8):Void;
public static function MinOfByteArray(ByteArray:unreal.VariantPtr, IndexOfMinValue:Int, MinValue:cpp.UInt8):Void;
public static function Lerp(A:cpp.Float32, B:cpp.Float32, Alpha:cpp.Float32):cpp.Float32;
public static function Ease(A:cpp.Float32, B:cpp.Float32, Alpha:cpp.Float32, EasingFunc:Int, BlendExp:cpp.Float32, Steps:Int):cpp.Float32;
public static function Round(A:cpp.Float32):Int;
public static function FFloor(A:cpp.Float32):Int;
public static function FTrunc(A:cpp.Float32):Int;
public static function FCeil(A:cpp.Float32):Int;
public static function Round64(A:cpp.Float32):unreal.Int64;
public static function FFloor64(A:cpp.Float32):unreal.Int64;
public static function FTrunc64(A:cpp.Float32):unreal.Int64;
public static function FCeil64(A:cpp.Float32):unreal.Int64;
public static function FMod(Dividend:cpp.Float32, Divisor:cpp.Float32, Remainder:cpp.Float32):Int;
public static function SignOfFloat(A:cpp.Float32):cpp.Float32;
public static function NormalizeToRange(Value:cpp.Float32, RangeMin:cpp.Float32, RangeMax:cpp.Float32):cpp.Float32;
public static function MapRangeUnclamped(Value:cpp.Float32, InRangeA:cpp.Float32, InRangeB:cpp.Float32, OutRangeA:cpp.Float32, OutRangeB:cpp.Float32):cpp.Float32;
public static function MapRangeClamped(Value:cpp.Float32, InRangeA:cpp.Float32, InRangeB:cpp.Float32, OutRangeA:cpp.Float32, OutRangeB:cpp.Float32):cpp.Float32;
public static function MultiplyByPi(Value:cpp.Float32):cpp.Float32;
public static function FInterpEaseInOut(A:cpp.Float32, B:cpp.Float32, Alpha:cpp.Float32, Exponent:cpp.Float32):cpp.Float32;
public static function MakePulsatingValue(InCurrentTime:cpp.Float32, InPulsesPerSecond:cpp.Float32, InPhase:cpp.Float32):cpp.Float32;
public static function FixedTurn(InCurrent:cpp.Float32, InDesired:cpp.Float32, InDeltaRate:cpp.Float32):cpp.Float32;
public static function IntPoint_Zero():unreal.VariantPtr;
public static function IntPoint_One():unreal.VariantPtr;
public static function IntPoint_Up():unreal.VariantPtr;
public static function IntPoint_Left():unreal.VariantPtr;
public static function IntPoint_Right():unreal.VariantPtr;
public static function IntPoint_Down():unreal.VariantPtr;
public static function Conv_IntPointToVector2D(InIntPoint:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_IntPointIntPoint(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_IntPointInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Subtract_IntPointIntPoint(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_IntPointInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Multiply_IntPointIntPoint(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_IntPointInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Divide_IntPointIntPoint(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Divide_IntPointInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Equal_IntPointIntPoint(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_IntPointIntPoint(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function Vector2D_One():unreal.VariantPtr;
public static function Vector2D_Unit45Deg():unreal.VariantPtr;
public static function Vector2D_Zero():unreal.VariantPtr;
public static function MakeVector2D(X:cpp.Float32, Y:cpp.Float32):unreal.VariantPtr;
public static function BreakVector2D(InVec:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32):Void;
public static function Conv_Vector2DToVector(InVector2D:unreal.VariantPtr, Z:cpp.Float32):unreal.VariantPtr;
public static function Conv_Vector2DToIntPoint(InVector2D:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_Vector2DFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Subtract_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_Vector2DFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Multiply_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_Vector2DFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Divide_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Divide_Vector2DFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function EqualExactly_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function EqualEqual_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function NotEqualExactly_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_Vector2DVector2D(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function Negated2D(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Set2D(A:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32):Void;
public static function ClampAxes2D(A:unreal.VariantPtr, MinAxisVal:cpp.Float32, MaxAxisVal:cpp.Float32):unreal.VariantPtr;
public static function CrossProduct2D(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function Distance2D(V1:unreal.VariantPtr, V2:unreal.VariantPtr):cpp.Float32;
public static function DistanceSquared2D(V1:unreal.VariantPtr, V2:unreal.VariantPtr):cpp.Float32;
public static function DotProduct2D(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function GetAbs2D(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetAbsMax2D(A:unreal.VariantPtr):cpp.Float32;
public static function GetMax2D(A:unreal.VariantPtr):cpp.Float32;
public static function GetMin2D(A:unreal.VariantPtr):cpp.Float32;
public static function GetRotated2D(A:unreal.VariantPtr, AngleDeg:cpp.Float32):unreal.VariantPtr;
public static function IsNearlyZero2D(A:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function IsZero2D(A:unreal.VariantPtr):Bool;
public static function Vector2DInterpTo(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function Vector2DInterpTo_Constant(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function NormalSafe2D(A:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Normal2D(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Normalize2D(A:unreal.VariantPtr, Tolerance:cpp.Float32):Void;
public static function Spherical2DToUnitCartesian(A:unreal.VariantPtr):unreal.VariantPtr;
public static function ToDirectionAndLength2D(A:unreal.VariantPtr, OutDir:unreal.VariantPtr, OutLength:cpp.Float32):Void;
public static function ToRounded2D(A:unreal.VariantPtr):unreal.VariantPtr;
public static function ToSign2D(A:unreal.VariantPtr):unreal.VariantPtr;
public static function VSize2D(A:unreal.VariantPtr):cpp.Float32;
public static function VSize2DSquared(A:unreal.VariantPtr):cpp.Float32;
public static function Vector_Zero():unreal.VariantPtr;
public static function Vector_One():unreal.VariantPtr;
public static function Vector_Forward():unreal.VariantPtr;
public static function Vector_Backward():unreal.VariantPtr;
public static function Vector_Up():unreal.VariantPtr;
public static function Vector_Down():unreal.VariantPtr;
public static function Vector_Right():unreal.VariantPtr;
public static function Vector_Left():unreal.VariantPtr;
public static function MakeVector(X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32):unreal.VariantPtr;
public static function CreateVectorFromYawPitch(Yaw:cpp.Float32, Pitch:cpp.Float32, Length:cpp.Float32):unreal.VariantPtr;
public static function Vector_Assign(A:unreal.VariantPtr, InVector:unreal.VariantPtr):Void;
public static function Vector_Set(A:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32):Void;
public static function BreakVector(InVec:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32):Void;
public static function Conv_VectorToLinearColor(InVec:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_VectorToTransform(InLocation:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_VectorToVector2D(InVector:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_VectorToRotator(InVec:unreal.VariantPtr):unreal.VariantPtr;
public static function RotatorFromAxisAndAngle(Axis:unreal.VariantPtr, Angle:cpp.Float32):unreal.VariantPtr;
public static function Conv_VectorToQuaternion(InVec:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_VectorFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Add_VectorInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Subtract_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_VectorFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Subtract_VectorInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Multiply_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_VectorFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Multiply_VectorInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function Divide_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Divide_VectorFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Divide_VectorInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function NegateVector(A:unreal.VariantPtr):unreal.VariantPtr;
public static function EqualExactly_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function EqualEqual_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function NotEqualExactly_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function Dot_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function Cross_VectorVector(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function GreaterGreater_VectorRotator(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function RotateAngleAxis(InVect:unreal.VariantPtr, AngleDeg:cpp.Float32, Axis:unreal.VariantPtr):unreal.VariantPtr;
public static function LessLess_VectorRotator(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_UnwindEuler(A:unreal.VariantPtr):Void;
public static function ClampVectorSize(A:unreal.VariantPtr, Min:cpp.Float32, Max:cpp.Float32):unreal.VariantPtr;
public static function Vector_ClampSize2D(A:unreal.VariantPtr, Min:cpp.Float32, Max:cpp.Float32):unreal.VariantPtr;
public static function Vector_ClampSizeMax(A:unreal.VariantPtr, Max:cpp.Float32):unreal.VariantPtr;
public static function Vector_ClampSizeMax2D(A:unreal.VariantPtr, Max:cpp.Float32):unreal.VariantPtr;
public static function GetMinElement(A:unreal.VariantPtr):cpp.Float32;
public static function GetMaxElement(A:unreal.VariantPtr):cpp.Float32;
public static function Vector_GetAbsMax(A:unreal.VariantPtr):cpp.Float32;
public static function Vector_GetAbsMin(A:unreal.VariantPtr):cpp.Float32;
public static function Vector_GetAbs(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_ComponentMin(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_ComponentMax(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_GetSignVector(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_GetProjection(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_HeadingAngle(A:unreal.VariantPtr):cpp.Float32;
public static function Vector_CosineAngle2D(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function Vector_ToRadians(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_ToDegrees(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_UnitCartesianToSpherical(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetDirectionUnitVector(From:unreal.VariantPtr, To:unreal.VariantPtr):unreal.VariantPtr;
public static function GetYawPitchFromVector(InVec:unreal.VariantPtr, Yaw:cpp.Float32, Pitch:cpp.Float32):Void;
public static function GetAzimuthAndElevation(InDirection:unreal.VariantPtr, ReferenceFrame:unreal.VariantPtr, Azimuth:cpp.Float32, Elevation:cpp.Float32):Void;
public static function GetVectorArrayAverage(Vectors:unreal.VariantPtr):unreal.VariantPtr;
public static function FTruncVector(InVector:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_Distance(V1:unreal.VariantPtr, V2:unreal.VariantPtr):cpp.Float32;
public static function Vector_DistanceSquared(V1:unreal.VariantPtr, V2:unreal.VariantPtr):cpp.Float32;
public static function Vector_Distance2D(V1:unreal.VariantPtr, V2:unreal.VariantPtr):cpp.Float32;
public static function Vector_Distance2DSquared(V1:unreal.VariantPtr, V2:unreal.VariantPtr):cpp.Float32;
public static function VSize(A:unreal.VariantPtr):cpp.Float32;
public static function VSizeSquared(A:unreal.VariantPtr):cpp.Float32;
public static function VSizeXY(A:unreal.VariantPtr):cpp.Float32;
public static function VSizeXYSquared(A:unreal.VariantPtr):cpp.Float32;
public static function Vector_IsNearlyZero(A:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function Vector_IsZero(A:unreal.VariantPtr):Bool;
public static function Vector_IsNAN(A:unreal.VariantPtr):Bool;
public static function Vector_IsUniform(A:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function Vector_IsUnit(A:unreal.VariantPtr, SquaredLenthTolerance:cpp.Float32):Bool;
public static function Vector_IsNormal(A:unreal.VariantPtr):Bool;
public static function Normal(A:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Vector_Normal2D(A:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Vector_NormalUnsafe(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_Normalize(A:unreal.VariantPtr, Tolerance:cpp.Float32):Void;
public static function VLerp(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32):unreal.VariantPtr;
public static function VEase(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32, EasingFunc:Int, BlendExp:cpp.Float32, Steps:Int):unreal.VariantPtr;
public static function VInterpTo(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function VInterpTo_Constant(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function VectorSpringInterp(Current:unreal.VariantPtr, Target:unreal.VariantPtr, SpringState:unreal.VariantPtr, Stiffness:cpp.Float32, CriticalDampingFactor:cpp.Float32, DeltaTime:cpp.Float32, Mass:cpp.Float32):unreal.VariantPtr;
public static function Vector_Reciprocal(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetReflectionVector(Direction:unreal.VariantPtr, SurfaceNormal:unreal.VariantPtr):unreal.VariantPtr;
public static function MirrorVectorByNormal(InVect:unreal.VariantPtr, InNormal:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_MirrorByPlane(A:unreal.VariantPtr, InPlane:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_SnappedToGrid(InVect:unreal.VariantPtr, InGridSize:cpp.Float32):unreal.VariantPtr;
public static function Vector_BoundedToCube(InVect:unreal.VariantPtr, InRadius:cpp.Float32):unreal.VariantPtr;
public static function Vector_AddBounded(A:unreal.VariantPtr, InAddVect:unreal.VariantPtr, InRadius:cpp.Float32):Void;
public static function Vector_BoundedToBox(InVect:unreal.VariantPtr, InBoxMin:unreal.VariantPtr, InBoxMax:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector_ProjectOnToNormal(V:unreal.VariantPtr, InNormal:unreal.VariantPtr):unreal.VariantPtr;
public static function ProjectVectorOnToVector(V:unreal.VariantPtr, Target:unreal.VariantPtr):unreal.VariantPtr;
public static function ProjectPointOnToPlane(Point:unreal.VariantPtr, PlaneBase:unreal.VariantPtr, PlaneNormal:unreal.VariantPtr):unreal.VariantPtr;
public static function ProjectVectorOnToPlane(V:unreal.VariantPtr, PlaneNormal:unreal.VariantPtr):unreal.VariantPtr;
public static function FindNearestPointsOnLineSegments(Segment1Start:unreal.VariantPtr, Segment1End:unreal.VariantPtr, Segment2Start:unreal.VariantPtr, Segment2End:unreal.VariantPtr, Segment1Point:unreal.VariantPtr, Segment2Point:unreal.VariantPtr):Void;
public static function FindClosestPointOnSegment(Point:unreal.VariantPtr, SegmentStart:unreal.VariantPtr, SegmentEnd:unreal.VariantPtr):unreal.VariantPtr;
public static function FindClosestPointOnLine(Point:unreal.VariantPtr, LineOrigin:unreal.VariantPtr, LineDirection:unreal.VariantPtr):unreal.VariantPtr;
public static function GetPointDistanceToSegment(Point:unreal.VariantPtr, SegmentStart:unreal.VariantPtr, SegmentEnd:unreal.VariantPtr):cpp.Float32;
public static function GetPointDistanceToLine(Point:unreal.VariantPtr, LineOrigin:unreal.VariantPtr, LineDirection:unreal.VariantPtr):cpp.Float32;
public static function RandomUnitVector():unreal.VariantPtr;
public static function RandomPointInBoundingBox(Origin:unreal.VariantPtr, BoxExtent:unreal.VariantPtr):unreal.VariantPtr;
public static function RandomUnitVectorInConeInRadians(ConeDir:unreal.VariantPtr, ConeHalfAngleInRadians:cpp.Float32):unreal.VariantPtr;
public static function RandomUnitVectorInConeInDegrees(ConeDir:unreal.VariantPtr, ConeHalfAngleInDegrees:cpp.Float32):unreal.VariantPtr;
public static function RandomUnitVectorInEllipticalConeInRadians(ConeDir:unreal.VariantPtr, MaxYawInRadians:cpp.Float32, MaxPitchInRadians:cpp.Float32):unreal.VariantPtr;
public static function RandomUnitVectorInEllipticalConeInDegrees(ConeDir:unreal.VariantPtr, MaxYawInDegrees:cpp.Float32, MaxPitchInDegrees:cpp.Float32):unreal.VariantPtr;
public static function Vector4_Zero():unreal.VariantPtr;
public static function MakeVector4(X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32, W:cpp.Float32):unreal.VariantPtr;
public static function BreakVector4(InVec:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32, W:cpp.Float32):Void;
public static function Conv_Vector4ToVector(InVector4:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_Vector4ToRotator(InVec:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_Vector4ToQuaternion(InVec:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Divide_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function EqualExactly_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function EqualEqual_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function NotEqualExactly_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_Vector4Vector4(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function Vector4_Negated(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector4_Assign(A:unreal.VariantPtr, InVector:unreal.VariantPtr):Void;
public static function Vector4_Set(A:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32, W:cpp.Float32):Void;
public static function Vector4_CrossProduct3(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector4_DotProduct(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function Vector4_DotProduct3(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function Vector4_IsNAN(A:unreal.VariantPtr):Bool;
public static function Vector4_IsNearlyZero3(A:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function Vector4_IsZero(A:unreal.VariantPtr):Bool;
public static function Vector4_Size(A:unreal.VariantPtr):cpp.Float32;
public static function Vector4_SizeSquared(A:unreal.VariantPtr):cpp.Float32;
public static function Vector4_Size3(A:unreal.VariantPtr):cpp.Float32;
public static function Vector4_SizeSquared3(A:unreal.VariantPtr):cpp.Float32;
public static function Vector4_IsUnit3(A:unreal.VariantPtr, SquaredLenthTolerance:cpp.Float32):Bool;
public static function Vector4_IsNormal3(A:unreal.VariantPtr):Bool;
public static function Vector4_Normal3(A:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Vector4_NormalUnsafe3(A:unreal.VariantPtr):unreal.VariantPtr;
public static function Vector4_Normalize3(A:unreal.VariantPtr, Tolerance:cpp.Float32):Void;
public static function Vector4_MirrorByVector3(Direction:unreal.VariantPtr, SurfaceNormal:unreal.VariantPtr):unreal.VariantPtr;
public static function TransformVector4(Matrix:unreal.VariantPtr, Vec4:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotator(Roll:cpp.Float32, Pitch:cpp.Float32, Yaw:cpp.Float32):unreal.VariantPtr;
public static function MakeRotFromX(X:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromY(Y:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromZ(Z:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromXY(X:unreal.VariantPtr, Y:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromXZ(X:unreal.VariantPtr, Z:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromYX(Y:unreal.VariantPtr, X:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromYZ(Y:unreal.VariantPtr, Z:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromZX(Z:unreal.VariantPtr, X:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotFromZY(Z:unreal.VariantPtr, Y:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRotationFromAxes(Forward:unreal.VariantPtr, Right:unreal.VariantPtr, Up:unreal.VariantPtr):unreal.VariantPtr;
public static function FindLookAtRotation(Start:unreal.VariantPtr, Target:unreal.VariantPtr):unreal.VariantPtr;
public static function BreakRotator(InRot:unreal.VariantPtr, Roll:cpp.Float32, Pitch:cpp.Float32, Yaw:cpp.Float32):Void;
public static function BreakRotIntoAxes(InRot:unreal.VariantPtr, X:unreal.VariantPtr, Y:unreal.VariantPtr, Z:unreal.VariantPtr):Void;
public static function EqualEqual_RotatorRotator(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function NotEqual_RotatorRotator(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function Multiply_RotatorFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Multiply_RotatorInt(A:unreal.VariantPtr, B:Int):unreal.VariantPtr;
public static function ComposeRotators(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function NegateRotator(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetForwardVector(InRot:unreal.VariantPtr):unreal.VariantPtr;
public static function GetRightVector(InRot:unreal.VariantPtr):unreal.VariantPtr;
public static function GetUpVector(InRot:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_RotatorToVector(InRot:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_RotatorToTransform(InRotator:unreal.VariantPtr):unreal.VariantPtr;
public static function GetAxes(A:unreal.VariantPtr, X:unreal.VariantPtr, Y:unreal.VariantPtr, Z:unreal.VariantPtr):Void;
public static function RandomRotator(bRoll:Bool):unreal.VariantPtr;
public static function RLerp(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32, bShortestPath:Bool):unreal.VariantPtr;
public static function REase(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32, bShortestPath:Bool, EasingFunc:Int, BlendExp:cpp.Float32, Steps:Int):unreal.VariantPtr;
public static function NormalizedDeltaRotator(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function ClampAxis(Angle:cpp.Float32):cpp.Float32;
public static function NormalizeAxis(Angle:cpp.Float32):cpp.Float32;
public static function Conv_MatrixToTransform(InMatrix:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_MatrixToRotator(InMatrix:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_GetOrigin(InMatrix:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_Identity():unreal.VariantPtr;
public static function Multiply_MatrixMatrix(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_MatrixMatrix(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_MatrixFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function EqualEqual_MatrixMatrix(A:unreal.VariantPtr, B:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function NotEqual_MatrixMatrix(A:unreal.VariantPtr, B:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function Matrix_TransformVector4(M:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_TransformPosition(M:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_InverseTransformPosition(M:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_TransformVector(M:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_InverseTransformVector(M:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_GetTransposed(M:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_GetDeterminant(M:unreal.VariantPtr):cpp.Float32;
public static function Matrix_GetRotDeterminant(M:unreal.VariantPtr):cpp.Float32;
public static function Matrix_GetInverse(M:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_GetTransposeAdjoint(M:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_RemoveScaling(M:unreal.VariantPtr, Tolerance:cpp.Float32):Void;
public static function Matrix_GetMatrixWithoutScale(M:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Matrix_GetScaleVector(M:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Matrix_RemoveTranslation(M:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_ConcatenateTranslation(M:unreal.VariantPtr, Translation:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_ContainsNaN(M:unreal.VariantPtr):Bool;
public static function Matrix_ScaleTranslation(M:unreal.VariantPtr, Scale3D:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_GetMaximumAxisScale(M:unreal.VariantPtr):cpp.Float32;
public static function Matrix_ApplyScale(M:unreal.VariantPtr, Scale:cpp.Float32):unreal.VariantPtr;
public static function Matrix_GetScaledAxis(M:unreal.VariantPtr, Axis:Int):unreal.VariantPtr;
public static function Matrix_GetScaledAxes(M:unreal.VariantPtr, X:unreal.VariantPtr, Y:unreal.VariantPtr, Z:unreal.VariantPtr):Void;
public static function Matrix_GetUnitAxis(M:unreal.VariantPtr, Axis:Int):unreal.VariantPtr;
public static function Matrix_GetUnitAxes(M:unreal.VariantPtr, X:unreal.VariantPtr, Y:unreal.VariantPtr, Z:unreal.VariantPtr):Void;
public static function Matrix_SetAxis(M:unreal.VariantPtr, Axis:Int, AxisVector:unreal.VariantPtr):Void;
public static function Matrix_SetOrigin(M:unreal.VariantPtr, NewOrigin:unreal.VariantPtr):Void;
public static function Matrix_GetColumn(M:unreal.VariantPtr, Column:Int):unreal.VariantPtr;
public static function Matrix_SetColumn(M:unreal.VariantPtr, Column:Int, Value:unreal.VariantPtr):Void;
public static function Matrix_GetRotator(M:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_ToQuat(M:unreal.VariantPtr):unreal.VariantPtr;
public static function Matrix_GetFrustumNearPlane(M:unreal.VariantPtr, OutPlane:unreal.VariantPtr):Bool;
public static function Matrix_GetFrustumFarPlane(M:unreal.VariantPtr, OutPlane:unreal.VariantPtr):Bool;
public static function Matrix_GetFrustumLeftPlane(M:unreal.VariantPtr, OutPlane:unreal.VariantPtr):Bool;
public static function Matrix_GetFrustumRightPlane(M:unreal.VariantPtr, OutPlane:unreal.VariantPtr):Bool;
public static function Matrix_GetFrustumTopPlane(M:unreal.VariantPtr, OutPlane:unreal.VariantPtr):Bool;
public static function Matrix_GetFrustumBottomPlane(M:unreal.VariantPtr, OutPlane:unreal.VariantPtr):Bool;
public static function Matrix_Mirror(M:unreal.VariantPtr, MirrorAxis:Int, FlipAxis:Int):unreal.VariantPtr;
public static function Quat_Identity():unreal.VariantPtr;
public static function EqualEqual_QuatQuat(A:unreal.VariantPtr, B:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function NotEqual_QuatQuat(A:unreal.VariantPtr, B:unreal.VariantPtr, ErrorTolerance:cpp.Float32):Bool;
public static function Add_QuatQuat(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_QuatQuat(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_QuatQuat(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_IsIdentity(Q:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function Quat_IsNormalized(Q:unreal.VariantPtr):Bool;
public static function Quat_IsFinite(Q:unreal.VariantPtr):Bool;
public static function Quat_IsNonFinite(Q:unreal.VariantPtr):Bool;
public static function Quat_AngularDistance(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function Quat_EnforceShortestArcWith(A:unreal.VariantPtr, B:unreal.VariantPtr):Void;
public static function Quat_Euler(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_Exp(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_GetAngle(Q:unreal.VariantPtr):cpp.Float32;
public static function Quat_GetAxisX(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_GetAxisY(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_GetAxisZ(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_VectorForward(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_VectorRight(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_VectorUp(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_Normalize(Q:unreal.VariantPtr, Tolerance:cpp.Float32):Void;
public static function Quat_Normalized(Q:unreal.VariantPtr, Tolerance:cpp.Float32):unreal.VariantPtr;
public static function Quat_GetRotationAxis(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_Inversed(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_Log(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_SetComponents(Q:unreal.VariantPtr, X:cpp.Float32, Y:cpp.Float32, Z:cpp.Float32, W:cpp.Float32):Void;
public static function Quat_SetFromEuler(Q:unreal.VariantPtr, Euler:unreal.VariantPtr):Void;
public static function Quat_MakeFromEuler(Euler:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_Rotator(Q:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_Size(Q:unreal.VariantPtr):cpp.Float32;
public static function Quat_SizeSquared(Q:unreal.VariantPtr):cpp.Float32;
public static function Quat_RotateVector(Q:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function Quat_UnrotateVector(Q:unreal.VariantPtr, V:unreal.VariantPtr):unreal.VariantPtr;
public static function LinearColor_White():unreal.VariantPtr;
public static function LinearColor_Gray():unreal.VariantPtr;
public static function LinearColor_Black():unreal.VariantPtr;
public static function LinearColor_Red():unreal.VariantPtr;
public static function LinearColor_Green():unreal.VariantPtr;
public static function LinearColor_Blue():unreal.VariantPtr;
public static function LinearColor_Yellow():unreal.VariantPtr;
public static function LinearColor_Transparent():unreal.VariantPtr;
public static function MakeColor(R:cpp.Float32, G:cpp.Float32, B:cpp.Float32, A:cpp.Float32):unreal.VariantPtr;
public static function BreakColor(InColor:unreal.VariantPtr, R:cpp.Float32, G:cpp.Float32, B:cpp.Float32, A:cpp.Float32):Void;
public static function LinearColor_Set(InOutColor:unreal.VariantPtr, InColor:unreal.VariantPtr):Void;
public static function LinearColor_SetRGBA(InOutColor:unreal.VariantPtr, R:cpp.Float32, G:cpp.Float32, B:cpp.Float32, A:cpp.Float32):Void;
public static function LinearColor_SetFromHSV(InOutColor:unreal.VariantPtr, H:cpp.Float32, S:cpp.Float32, V:cpp.Float32, A:cpp.Float32):Void;
public static function LinearColor_SetFromSRGB(InOutColor:unreal.VariantPtr, InSRGB:unreal.VariantPtr):Void;
public static function LinearColor_SetFromPow22(InOutColor:unreal.VariantPtr, InColor:unreal.VariantPtr):Void;
public static function LinearColor_SetTemperature(InOutColor:unreal.VariantPtr, InTemperature:cpp.Float32):Void;
public static function LinearColor_SetRandomHue(InOutColor:unreal.VariantPtr):Void;
public static function Conv_FloatToLinearColor(InFloat:cpp.Float32):unreal.VariantPtr;
public static function HSVToRGB(H:cpp.Float32, S:cpp.Float32, V:cpp.Float32, A:cpp.Float32):unreal.VariantPtr;
public static function HSVToRGB_Vector(HSV:unreal.VariantPtr, RGB:unreal.VariantPtr):Void;
public static function HSVToRGBLinear(HSV:unreal.VariantPtr):unreal.VariantPtr;
public static function RGBToHSV(InColor:unreal.VariantPtr, H:cpp.Float32, S:cpp.Float32, V:cpp.Float32, A:cpp.Float32):Void;
public static function RGBToHSV_Vector(RGB:unreal.VariantPtr, HSV:unreal.VariantPtr):Void;
public static function RGBLinearToHSV(RGB:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_LinearColorToVector(InLinearColor:unreal.VariantPtr):unreal.VariantPtr;
public static function LinearColor_ToRGBE(InLinearColor:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_LinearColorToColor(InLinearColor:unreal.VariantPtr, InUseSRGB:Bool):unreal.VariantPtr;
public static function LinearColor_Quantize(InColor:unreal.VariantPtr):unreal.VariantPtr;
public static function LinearColor_QuantizeRound(InColor:unreal.VariantPtr):unreal.VariantPtr;
public static function LinearColor_Desaturated(InColor:unreal.VariantPtr, InDesaturation:cpp.Float32):unreal.VariantPtr;
public static function LinearColor_Distance(C1:unreal.VariantPtr, C2:unreal.VariantPtr):cpp.Float32;
public static function LinearColor_ToNewOpacity(InColor:unreal.VariantPtr, InOpacity:cpp.Float32):unreal.VariantPtr;
public static function LinearColor_GetLuminance(InColor:unreal.VariantPtr):cpp.Float32;
public static function LinearColor_GetMax(InColor:unreal.VariantPtr):cpp.Float32;
public static function LinearColor_GetMin(InColor:unreal.VariantPtr):cpp.Float32;
public static function CInterpTo(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function LinearColorLerp(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32):unreal.VariantPtr;
public static function LinearColorLerpUsingHSV(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32):unreal.VariantPtr;
public static function LinearColor_IsNearEqual(A:unreal.VariantPtr, B:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function EqualEqual_LinearColorLinearColor(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_LinearColorLinearColor(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function Add_LinearColorLinearColor(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_LinearColorLinearColor(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_LinearColorLinearColor(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_LinearColorFloat(A:unreal.VariantPtr, B:cpp.Float32):unreal.VariantPtr;
public static function Divide_LinearColorLinearColor(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function MakePlaneFromPointAndNormal(Point:unreal.VariantPtr, Normal:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeDateTime(Year:Int, Month:Int, Day:Int, Hour:Int, Minute:Int, Second:Int, Millisecond:Int):unreal.VariantPtr;
public static function BreakDateTime(InDateTime:unreal.VariantPtr, Year:Int, Month:Int, Day:Int, Hour:Int, Minute:Int, Second:Int, Millisecond:Int):Void;
public static function Add_DateTimeTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_DateTimeTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Add_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function EqualEqual_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function Greater_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function GreaterEqual_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function Less_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function LessEqual_DateTimeDateTime(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function GetDate(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetDay(A:unreal.VariantPtr):Int;
public static function GetDayOfYear(A:unreal.VariantPtr):Int;
public static function GetHour(A:unreal.VariantPtr):Int;
public static function GetHour12(A:unreal.VariantPtr):Int;
public static function GetMillisecond(A:unreal.VariantPtr):Int;
public static function GetMinute(A:unreal.VariantPtr):Int;
public static function GetMonth(A:unreal.VariantPtr):Int;
public static function GetSecond(A:unreal.VariantPtr):Int;
public static function GetTimeOfDay(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetYear(A:unreal.VariantPtr):Int;
public static function IsAfternoon(A:unreal.VariantPtr):Bool;
public static function IsMorning(A:unreal.VariantPtr):Bool;
public static function DaysInMonth(Year:Int, Month:Int):Int;
public static function DaysInYear(Year:Int):Int;
public static function IsLeapYear(Year:Int):Bool;
public static function DateTimeMaxValue():unreal.VariantPtr;
public static function DateTimeMinValue():unreal.VariantPtr;
public static function Now():unreal.VariantPtr;
public static function Today():unreal.VariantPtr;
public static function UtcNow():unreal.VariantPtr;
public static function DateTimeFromIsoString(IsoString:unreal.VariantPtr, Result:unreal.VariantPtr):Bool;
public static function DateTimeFromString(DateTimeString:unreal.VariantPtr, Result:unreal.VariantPtr):Bool;
public static function TimespanMaxValue():unreal.VariantPtr;
public static function TimespanMinValue():unreal.VariantPtr;
public static function TimespanZeroValue():unreal.VariantPtr;
public static function MakeTimespan(Days:Int, Hours:Int, Minutes:Int, Seconds:Int, Milliseconds:Int):unreal.VariantPtr;
public static function MakeTimespan2(Days:Int, Hours:Int, Minutes:Int, Seconds:Int, FractionNano:Int):unreal.VariantPtr;
public static function BreakTimespan(InTimespan:unreal.VariantPtr, Days:Int, Hours:Int, Minutes:Int, Seconds:Int, Milliseconds:Int):Void;
public static function BreakTimespan2(InTimespan:unreal.VariantPtr, Days:Int, Hours:Int, Minutes:Int, Seconds:Int, FractionNano:Int):Void;
public static function Add_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Subtract_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function Multiply_TimespanFloat(A:unreal.VariantPtr, Scalar:cpp.Float32):unreal.VariantPtr;
public static function Divide_TimespanFloat(A:unreal.VariantPtr, Scalar:cpp.Float32):unreal.VariantPtr;
public static function EqualEqual_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function Greater_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function GreaterEqual_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function Less_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function LessEqual_TimespanTimespan(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function GetDays(A:unreal.VariantPtr):Int;
public static function GetDuration(A:unreal.VariantPtr):unreal.VariantPtr;
public static function GetHours(A:unreal.VariantPtr):Int;
public static function GetMilliseconds(A:unreal.VariantPtr):Int;
public static function GetMinutes(A:unreal.VariantPtr):Int;
public static function GetSeconds(A:unreal.VariantPtr):Int;
public static function GetTotalDays(A:unreal.VariantPtr):cpp.Float32;
public static function GetTotalHours(A:unreal.VariantPtr):cpp.Float32;
public static function GetTotalMilliseconds(A:unreal.VariantPtr):cpp.Float32;
public static function GetTotalMinutes(A:unreal.VariantPtr):cpp.Float32;
public static function GetTotalSeconds(A:unreal.VariantPtr):cpp.Float32;
public static function FromDays(Days:cpp.Float32):unreal.VariantPtr;
public static function FromHours(Hours:cpp.Float32):unreal.VariantPtr;
public static function FromMilliseconds(Milliseconds:cpp.Float32):unreal.VariantPtr;
public static function FromMinutes(Minutes:cpp.Float32):unreal.VariantPtr;
public static function FromSeconds(Seconds:cpp.Float32):unreal.VariantPtr;
public static function TimespanRatio(A:unreal.VariantPtr, B:unreal.VariantPtr):cpp.Float32;
public static function TimespanFromString(TimespanString:unreal.VariantPtr, Result:unreal.VariantPtr):Bool;
public static function MakeQualifiedFrameTime(Frame:unreal.VariantPtr, FrameRate:unreal.VariantPtr, SubFrame:cpp.Float32):unreal.VariantPtr;
public static function BreakQualifiedFrameTime(InFrameTime:unreal.VariantPtr, Frame:unreal.VariantPtr, FrameRate:unreal.VariantPtr, SubFrame:cpp.Float32):Void;
public static function MakeFrameRate(Numerator:Int, Denominator:Int):unreal.VariantPtr;
public static function BreakFrameRate(InFrameRate:unreal.VariantPtr, Numerator:Int, Denominator:Int):Void;
public static function Conv_ByteToFloat(InByte:cpp.UInt8):cpp.Float32;
public static function Conv_IntToFloat(InInt:Int):cpp.Float32;
public static function Conv_IntToInt64(InInt:Int):unreal.Int64;
public static function Conv_IntToByte(InInt:Int):cpp.UInt8;
public static function Conv_Int64ToInt(InInt:unreal.Int64):Int;
public static function Conv_Int64ToByte(InInt:unreal.Int64):cpp.UInt8;
public static function Conv_IntToIntVector(InInt:Int):unreal.VariantPtr;
public static function Conv_IntToBool(InInt:Int):Bool;
public static function Conv_BoolToInt(InBool:Bool):Int;
public static function Conv_BoolToFloat(InBool:Bool):cpp.Float32;
public static function Conv_BoolToByte(InBool:Bool):cpp.UInt8;
public static function Conv_ByteToInt(InByte:cpp.UInt8):Int;
public static function Conv_ColorToLinearColor(InColor:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_IntVectorToVector(InIntVector:unreal.VariantPtr):unreal.VariantPtr;
public static function Conv_FloatToVector(InFloat:cpp.Float32):unreal.VariantPtr;
public static function MakeBox(Min:unreal.VariantPtr, Max:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeBox2D(Min:unreal.VariantPtr, Max:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRandomStream(InitialSeed:Int):unreal.VariantPtr;
public static function BreakRandomStream(InRandomStream:unreal.VariantPtr, InitialSeed:Int):Void;
public static function SelectString(A:unreal.VariantPtr, B:unreal.VariantPtr, bPickA:Bool):unreal.VariantPtr;
public static function SelectInt(A:Int, B:Int, bPickA:Bool):Int;
public static function SelectFloat(A:cpp.Float32, B:cpp.Float32, bPickA:Bool):cpp.Float32;
public static function SelectVector(A:unreal.VariantPtr, B:unreal.VariantPtr, bPickA:Bool):unreal.VariantPtr;
public static function SelectRotator(A:unreal.VariantPtr, B:unreal.VariantPtr, bPickA:Bool):unreal.VariantPtr;
public static function SelectColor(A:unreal.VariantPtr, B:unreal.VariantPtr, bPickA:Bool):unreal.VariantPtr;
public static function SelectTransform(A:unreal.VariantPtr, B:unreal.VariantPtr, bPickA:Bool):unreal.VariantPtr;
public static function SelectObject(A:unreal.UIntPtr, B:unreal.UIntPtr, bSelectA:Bool):unreal.UIntPtr;
public static function SelectClass(A:unreal.UIntPtr, B:unreal.UIntPtr, bSelectA:Bool):unreal.UIntPtr;
public static function EqualEqual_ObjectObject(A:unreal.UIntPtr, B:unreal.UIntPtr):Bool;
public static function NotEqual_ObjectObject(A:unreal.UIntPtr, B:unreal.UIntPtr):Bool;
public static function EqualEqual_ClassClass(A:unreal.UIntPtr, B:unreal.UIntPtr):Bool;
public static function NotEqual_ClassClass(A:unreal.UIntPtr, B:unreal.UIntPtr):Bool;
public static function ClassIsChildOf(TestClass:unreal.UIntPtr, ParentClass:unreal.UIntPtr):Bool;
public static function EqualEqual_NameName(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NotEqual_NameName(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function MakeTransform(Location:unreal.VariantPtr, Rotation:unreal.VariantPtr, Scale:unreal.VariantPtr):unreal.VariantPtr;
public static function BreakTransform(InTransform:unreal.VariantPtr, Location:unreal.VariantPtr, Rotation:unreal.VariantPtr, Scale:unreal.VariantPtr):Void;
public static function EqualEqual_TransformTransform(A:unreal.VariantPtr, B:unreal.VariantPtr):Bool;
public static function NearlyEqual_TransformTransform(A:unreal.VariantPtr, B:unreal.VariantPtr, LocationTolerance:cpp.Float32, RotationTolerance:cpp.Float32, Scale3DTolerance:cpp.Float32):Bool;
public static function ComposeTransforms(A:unreal.VariantPtr, B:unreal.VariantPtr):unreal.VariantPtr;
public static function TransformLocation(T:unreal.VariantPtr, Location:unreal.VariantPtr):unreal.VariantPtr;
public static function TransformDirection(T:unreal.VariantPtr, Direction:unreal.VariantPtr):unreal.VariantPtr;
public static function TransformRotation(T:unreal.VariantPtr, Rotation:unreal.VariantPtr):unreal.VariantPtr;
public static function InverseTransformLocation(T:unreal.VariantPtr, Location:unreal.VariantPtr):unreal.VariantPtr;
public static function InverseTransformDirection(T:unreal.VariantPtr, Direction:unreal.VariantPtr):unreal.VariantPtr;
public static function InverseTransformRotation(T:unreal.VariantPtr, Rotation:unreal.VariantPtr):unreal.VariantPtr;
public static function MakeRelativeTransform(A:unreal.VariantPtr, RelativeTo:unreal.VariantPtr):unreal.VariantPtr;
public static function ConvertTransformToRelative(Transform:unreal.VariantPtr, ParentTransform:unreal.VariantPtr):unreal.VariantPtr;
public static function InvertTransform(T:unreal.VariantPtr):unreal.VariantPtr;
public static function TLerp(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32, InterpMode:Int):unreal.VariantPtr;
public static function TEase(A:unreal.VariantPtr, B:unreal.VariantPtr, Alpha:cpp.Float32, EasingFunc:Int, BlendExp:cpp.Float32, Steps:Int):unreal.VariantPtr;
public static function TInterpTo(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function Transform_Determinant(Transform:unreal.VariantPtr):cpp.Float32;
public static function Conv_TransformToMatrix(Transform:unreal.VariantPtr):unreal.VariantPtr;
public static function FInterpTo(Current:cpp.Float32, Target:cpp.Float32, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):cpp.Float32;
public static function FInterpTo_Constant(Current:cpp.Float32, Target:cpp.Float32, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):cpp.Float32;
public static function RInterpTo(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function RInterpTo_Constant(Current:unreal.VariantPtr, Target:unreal.VariantPtr, DeltaTime:cpp.Float32, InterpSpeed:cpp.Float32):unreal.VariantPtr;
public static function FloatSpringInterp(Current:cpp.Float32, Target:cpp.Float32, SpringState:unreal.VariantPtr, Stiffness:cpp.Float32, CriticalDampingFactor:cpp.Float32, DeltaTime:cpp.Float32, Mass:cpp.Float32):cpp.Float32;
public static function ResetFloatSpringState(SpringState:unreal.VariantPtr):Void;
public static function ResetVectorSpringState(SpringState:unreal.VariantPtr):Void;
public static function RandomIntegerFromStream(Max:Int, Stream:unreal.VariantPtr):Int;
public static function RandomIntegerInRangeFromStream(Min:Int, Max:Int, Stream:unreal.VariantPtr):Int;
public static function RandomBoolFromStream(Stream:unreal.VariantPtr):Bool;
public static function RandomFloatFromStream(Stream:unreal.VariantPtr):cpp.Float32;
public static function RandomFloatInRangeFromStream(Min:cpp.Float32, Max:cpp.Float32, Stream:unreal.VariantPtr):cpp.Float32;
public static function RandomUnitVectorFromStream(Stream:unreal.VariantPtr):unreal.VariantPtr;
public static function RandomRotatorFromStream(bRoll:Bool, Stream:unreal.VariantPtr):unreal.VariantPtr;
public static function ResetRandomStream(Stream:unreal.VariantPtr):Void;
public static function SeedRandomStream(Stream:unreal.VariantPtr):Void;
public static function SetRandomStreamSeed(Stream:unreal.VariantPtr, NewSeed:Int):Void;
public static function RandomUnitVectorInConeInRadiansFromStream(ConeDir:unreal.VariantPtr, ConeHalfAngleInRadians:cpp.Float32, Stream:unreal.VariantPtr):unreal.VariantPtr;
public static function RandomUnitVectorInConeInDegreesFromStream(ConeDir:unreal.VariantPtr, ConeHalfAngleInDegrees:cpp.Float32, Stream:unreal.VariantPtr):unreal.VariantPtr;
public static function RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir:unreal.VariantPtr, MaxYawInRadians:cpp.Float32, MaxPitchInRadians:cpp.Float32, Stream:unreal.VariantPtr):unreal.VariantPtr;
public static function RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir:unreal.VariantPtr, MaxYawInDegrees:cpp.Float32, MaxPitchInDegrees:cpp.Float32, Stream:unreal.VariantPtr):unreal.VariantPtr;
public static function PerlinNoise1D(Value:cpp.Float32):cpp.Float32;
public static function MinimumAreaRectangle(WorldContextObject:unreal.UIntPtr, InVerts:unreal.VariantPtr, SampleSurfaceNormal:unreal.VariantPtr, OutRectCenter:unreal.VariantPtr, OutRectRotation:unreal.VariantPtr, OutSideLengthX:cpp.Float32, OutSideLengthY:cpp.Float32, bDebugDraw:Bool):Void;
public static function PointsAreCoplanar(Points:unreal.VariantPtr, Tolerance:cpp.Float32):Bool;
public static function IsPointInBox(Point:unreal.VariantPtr, BoxOrigin:unreal.VariantPtr, BoxExtent:unreal.VariantPtr):Bool;
public static function IsPointInBoxWithTransform(Point:unreal.VariantPtr, BoxWorldTransform:unreal.VariantPtr, BoxExtent:unreal.VariantPtr):Bool;
public static function GetSlopeDegreeAngles(MyRightYAxis:unreal.VariantPtr, FloorNormal:unreal.VariantPtr, UpVector:unreal.VariantPtr, OutSlopePitchDegreeAngle:cpp.Float32, OutSlopeRollDegreeAngle:cpp.Float32):Void;
public static function LinePlaneIntersection(LineStart:unreal.VariantPtr, LineEnd:unreal.VariantPtr, APlane:unreal.VariantPtr, T:cpp.Float32, Intersection:unreal.VariantPtr):Bool;
public static function LinePlaneIntersection_OriginNormal(LineStart:unreal.VariantPtr, LineEnd:unreal.VariantPtr, PlaneOrigin:unreal.VariantPtr, PlaneNormal:unreal.VariantPtr, T:cpp.Float32, Intersection:unreal.VariantPtr):Bool;
public static function WeightedMovingAverage_Float(CurrentSample:cpp.Float32, PreviousSample:cpp.Float32, Weight:cpp.Float32):cpp.Float32;
public static function WeightedMovingAverage_FVector(CurrentSample:unreal.VariantPtr, PreviousSample:unreal.VariantPtr, Weight:cpp.Float32):unreal.VariantPtr;
public static function WeightedMovingAverage_FRotator(CurrentSample:unreal.VariantPtr, PreviousSample:unreal.VariantPtr, Weight:cpp.Float32):unreal.VariantPtr;
public static function DynamicWeightedMovingAverage_Float(CurrentSample:cpp.Float32, PreviousSample:cpp.Float32, MaxDistance:cpp.Float32, MinWeight:cpp.Float32, MaxWeight:cpp.Float32):cpp.Float32;
public static function DynamicWeightedMovingAverage_FVector(CurrentSample:unreal.VariantPtr, PreviousSample:unreal.VariantPtr, MaxDistance:cpp.Float32, MinWeight:cpp.Float32, MaxWeight:cpp.Float32):unreal.VariantPtr;
public static function DynamicWeightedMovingAverage_FRotator(CurrentSample:unreal.VariantPtr, PreviousSample:unreal.VariantPtr, MaxDistance:cpp.Float32, MinWeight:cpp.Float32, MaxWeight:cpp.Float32):unreal.VariantPtr;
public static function StaticClass():unreal.UIntPtr;
}